# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2022, Daniel Webber (mendax1234)
# This file is distributed under the same license as the 6940 Swerve package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# zhang jiaming, 2022
# Daniel Webber, 2022
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: 6940 Swerve\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-10-17 11:04+0000\n"
"PO-Revision-Date: 2022-07-04 16:26+0000\n"
"Last-Translator: Daniel Webber, 2022\n"
"Language-Team: Chinese (China) (https://www.transifex.com/frc-team-6940-1/teams/135321/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../source/docs/software-info-team1684/swerve-in-auton/the-math.rst:2
#: 1bd8cf3ba8d040c791e72382abd00fef
msgid "The Math Behind the Magic"
msgstr "神奇的移动背后的数学原理"

#: ../source/docs/software-info-team1684/swerve-in-auton/the-math.rst:3
#: 3fa964d2d5e746958ab6b9fe01001481
msgid ""
"One of the core differences when operating in autonomous mode is that the "
"robot can't receive information about where it is from the driver, in the "
"form of controls. Early on, we established that we want to accurately and "
"repeatably control our movements and actions. To do this, the robot needs to"
" know where it is at all times - or at least have a good guess. This is "
"known as `odometry <https://en.wikipedia.org/wiki/Odometry>`_ within the "
"field of robotics. Without accurate odometry, we're forced to use `dead "
"reckoning <https://en.wikipedia.org/wiki/Dead_reckoning>`_ , or worse, time-"
"based movements at approximate speeds."
msgstr ""
"自动模式下的移动与手动模式下最核心的区别就在于自动模式下的机器人不能从driver那里获得任何信息。因此，为了可以精确地并且重复地控制机器人的移动与动作，机器人需要知道它在赛场的何方——或者至少有个大概的猜测。这一过程在机器人的领域中被称为"
"  `odometry "
"<https://en.wikipedia.org/wiki/Odometry>`_。如果没有办法精确地预测机器人的位置，我们就智能被迫采用 `dead"
" reckoning <https://en.wikipedia.org/wiki/Dead_reckoning>`_ "
"，即死记硬背法。甚至，我们可能会需要采用基于时间的控制方法"

#: ../source/docs/software-info-team1684/swerve-in-auton/the-math.rst:10
#: f95bed7205cc4c518a847d1f19003f97
msgid ""
"In order to perform our odometry, we decided to use our wheel encoders "
"combined with a gyroscope. By performing the reverse of what we do in "
"teleop, which is taking an intended output pose and figuring out what each "
"individual actuator should be doing to achieve that pose. Again, a pose is "
"simply a set of unique characteristics describing the robot's position or "
"motion at an instant in time. By taking information about the velocity and "
"direction of each wheel and combining it using the kinematics we described "
"in section 2.1, we can obtain an overall velocity of the robot in two "
"directions; this is referred to as Forward Kinematics, or FK. By integrating"
" this over time (just multiplying the velocity at this time with the time "
"step of the controller), we can get our position."
msgstr ""
"为了执行我们的odometry，我们决定将我们的车轮编码器与陀螺仪相结合。执行与我们在手动控制中所做的反向运动学计算，设定一个预定的输出姿态，并找出每个单独的这轮应该如何运动来实现该姿态。同时，一个姿态只是一组描述机器人在某一瞬间的位置或运动的独特特征。而通过获取每个瞬间各个车轮的速度和方向的信息，并使用我们在第2.1节中描述的运动学进行组合，我们可以得到机器人在两个方向上的整体速度，进而通过对时间积分（只需将此时的速度与控制器的时间步长相乘），得到我们的位置，这一个过程被称为“正向运动学”，即FK"

#: ../source/docs/software-info-team1684/swerve-in-auton/the-math.rst:20
#: a8207195feb745d0b6e37b01d94cbadc
msgid "Forward Kinematics (FK)"
msgstr "正向运动学（FK）"

#: ../source/docs/software-info-team1684/swerve-in-auton/the-math.rst:21
#: 9bc7149ed2bb4c3780f830230eafc5f4
msgid ""
"Of course, going from wheel encoders to overall velocity is not entirely "
"straightforward. The problem comes when we look at our information and "
"desired results: we have eight variables, four wheel speeds and four "
"directions, and we want three outputs: the robot's forward, sideways, and "
"rotational velocity. If you're familiar with algebra, especially linear "
"algebra, you might recognize that this makes our system overdefined. We have"
" more information than we need, and can't obtain an exact analytic solution."
" There's a couple ways to solve this. By `setting up the exact equations and"
" putting them into a computer algebra system "
"<https://www.chiefdelphi.com/t/paper-4-wheel-independent-drive-independent-"
"steering-swerve/107383>`_ , or by assembling the equations in a matrix-"
"vector format and using a linear equation solver, we can obtain a “best-fit”"
" to the system."
msgstr ""
"当然，从车轮编码器到整体速度并不是完全直接的。当我们看到能获取的信息和我们期望的结果时，问题就来了：我们有八个变量，四个轮子的速度和四个方向，而我们想要三个输出：机器人的前进、侧向和旋转速度。如果你熟悉代数，特别是线性代数，你可能会认识到，这使得我们的系统被过度定义了——3个未知数，但是8个方程。我们有更多的信息，无法得到一个精确的结果。有几种方法来解决这个问题。通过"
"  `设置精确的方程并将其放入计算机代数系统<https://www.chiefdelphi.com/t/paper-4-wheel-"
"independent-drive-independent-steering-swerve/107383>`_ ，或者通过将方程以矩阵-"
"向量格式组合并使用线性方程求解器，我们可以获得系统的 \"最佳拟合\"。"

#: ../source/docs/software-info-team1684/swerve-in-auton/the-math.rst:30
#: 09b7713651fd463f80c5a6a269dcc868
msgid ""
"However, this sort of inexact fitting can be difficult to implement, often "
"requiring inclusion of extra libraries. Due to the time sensitivity of the "
"season, we chose to take a simplified approach. `Courtesy of Kyle Lanman of "
"team 2841, we adapted an algorithm "
"<https://www.chiefdelphi.com/t/calculating-odometry-of-a-swerve-"
"drive/160043/6>`_ that averages variables until we get from eight down to "
"the three we need. While we expect this to be less accurate than more "
"advanced methods, we found it to be remarkably accurate after calibration. "
"As long as wheel speeds and acceleration are kept below the point where "
"they'd slip under normal conditions, this proves to be a suitable odometry "
"method for the limitations of the 15 second autonomous period, especially "
"when combined with other sensors to “close the loop” on navigation."
msgstr ""
"然而，这种不精确的拟合可能很难实现，往往需要加入额外的库。由于本赛季的时间很紧，我们选择了一种简化的方法。由2841队的Kyle "
"Lanman提供，我们改编了  `这种算法<https://www.chiefdelphi.com/t/calculating-odometry-of-"
"a-swerve-drive/160043/6>`_ "
"，对变量直接取均值，直到我们从8个下降到我们需要的3个。虽然我们预计这不如更先进的方法准确，但我们发现它在校准后是非常准确的。只要轮速和加速度保持不会让机器打滑，这就是一种适合15秒自动时段的里程表测量方法，特别是当与其他传感器结合使用以"
" \"校正\"导航时。"

#: ../source/docs/software-info-team1684/swerve-in-auton/the-math.rst:39
#: f3d9a7bf4e8642e0afbeef2906916854
msgid ""
"In this formulation of forward kinematics, we start from a position where we"
" assume we know our wheel speeds and wheel angles; call them with "
":math:`ws_{FR}`, :math:`ws_{FL}`, :math:`wa_{RL}`,and so on, with F/R and "
"L/R again representing front/rear and left/right. Using motors that have a "
"built in encoder, such as CTRE Falcon 500s or REV Neos, is advantageous for "
"determining wheel speed."
msgstr ""
"在这种形式的正向运动学中，我们先假设，在某一时刻，我们与到我们的车轮速度与朝向——我们将其定义为：math:`ws_{FR}`, "
":math:`ws_{FL}`, :math:`wa_{RL}` ，以此类推，F/R与F/R分别表示左右、前后。通过电机内置的编码器——例如CTRE "
"Falcon 500或者REV Neos内置的编码器，来决定轮速是极其麻烦的。"

#: ../source/docs/software-info-team1684/swerve-in-auton/the-math.rst:44
#: 41cbd7ac68714d44a28b8185fef4a999
msgid ""
"We do need to make sure we've consistent, physically meaningful values for "
"our wheel speeds. Whether we're using encoders built into the motor or ones "
"installed manually, they're likely putting out some counter of ticks, or "
"count of revolutions, or some speed of ticks/second or revolutions/second. "
"We'll need to use this in combination with our drivetrain reduction and "
"wheel diameter to get some conversion rate, and thus be able to get our "
"wheel speeds in units of distance per time, like in/sec, ft/sec, or m/sec."
msgstr ""
"我们一定需要确保我们的车轮速度有一致的、有物理意义的数值。无论我们使用的是内置在电机中的编码器还是手动安装的编码器，它们都可能向我们提供的是以刻度和转数为单位的值，或一些刻度/秒或转数/秒的速度。我们需要将其与我们的传动系统减速和车轮直径结合起来，以获得一些转换率，从而能够获得我们的车轮速度，以每一时间的距离为单位，如英寸/秒、英尺/秒或米/秒。"

#: ../source/docs/software-info-team1684/swerve-in-auton/the-math.rst:51
#: e26525679e814cde9806543611254049
msgid ""
"We can first calculate A, B, C, and D values from our wheelspeeds and "
"angles, but this time, we're going to calculate them for each wheel. These "
"will be in units of velocity (distance per me), as we're simply multiplying "
"our wheel speed (which has those units) by an angle component."
msgstr ""
"我们可以先用我们的轮速与角度计算ABCD四个数值，但这次，我们对每个轮子都要计算一次，单位是速度（每分钟的距离）因为我们只是将我们的轮子的转速（度每分钟）乘以一个角度分量——即每度对应的距离。"

#: ../source/docs/software-info-team1684/swerve-in-auton/the-math.rst:55
#: e2ff47a62a4c4d9290ed93371a6c2871
msgid ""
"B_{FL} = sin(wa_{FL}) * ws_{FL}\n"
"\n"
msgstr ""
"B_{FL} = sin(wa_{FL}) * ws_{FL}\n"
"\n"

#: ../source/docs/software-info-team1684/swerve-in-auton/the-math.rst:56
#: 1e0cc592f7fa49ae845fc6a52d468df6
msgid ""
"D_{FL} = cos(wa_{FL}) * ws_{FL}\n"
"\n"
msgstr ""
"D_{FL} = cos(wa_{FL}) * ws_{FL}\n"
"\n"

#: ../source/docs/software-info-team1684/swerve-in-auton/the-math.rst:57
#: 98274c1f647c48bfb981ded8c4438d7e
msgid ""
"B_{FR} = sin(wa_{FR}) * ws_{FR}\n"
"\n"
msgstr ""
"B_{FR} = sin(wa_{FR}) * ws_{FR}\n"
"\n"

#: ../source/docs/software-info-team1684/swerve-in-auton/the-math.rst:58
#: ae63336185124739becc71d6bfe86b34
msgid ""
"C_{FR} = cos(wa_{FR}) * ws_{FR}\n"
"\n"
msgstr ""
"C_{FR} = cos(wa_{FR}) * ws_{FR}\n"
"\n"

#: ../source/docs/software-info-team1684/swerve-in-auton/the-math.rst:59
#: 4fdb7cb86cc143fb817403c60ba06e48
msgid ""
"A_{RL} = sin(wa_{RL}) * ws_{RL}\n"
"\n"
msgstr ""
"A_{RL} = sin(wa_{RL}) * ws_{RL}\n"
"\n"

#: ../source/docs/software-info-team1684/swerve-in-auton/the-math.rst:60
#: 46ef2ea5fa364e5baa1f51754263aaf0
msgid ""
"D_{RL} = cos(wa_{RL}) * ws_{RL}\n"
"\n"
msgstr ""
"D_{RL} = cos(wa_{RL}) * ws_{RL}\n"
"\n"

#: ../source/docs/software-info-team1684/swerve-in-auton/the-math.rst:61
#: 0c1196fedc4a4e0e9d775b1560c8e93d
msgid ""
"A_{RR} = sin(wa_{RR}) * ws_{RR}\n"
"\n"
msgstr ""
"A_{RR} = sin(wa_{RR}) * ws_{RR}\n"
"\n"

#: ../source/docs/software-info-team1684/swerve-in-auton/the-math.rst:62
#: 2b8e416c1a9e4746b01a65fa7890f98d
msgid ""
"C_{RR} = cos(wa_{RR}) * ws_{RR}\n"
"\n"
msgstr ""
"C_{RR} = cos(wa_{RR}) * ws_{RR}\n"
"\n"

#: ../source/docs/software-info-team1684/swerve-in-auton/the-math.rst:64
#: 5e0ce6b3b6fb4206adcccdbcf836bcbf
msgid ""
"Well that wasn't much help with simplifying our variables! In order to make "
"this more reasonable, we're going to do some averaging. For each value of A,"
" B, C, and D, we're going to take the two values we have, and average them. "
"These averaged values will still have units of velocity, as they're just "
"averaging two other velocity values."
msgstr ""
"好吧，这对简化我们的变量没有任何帮助! "
"为了使之更合理，我们要开始取均值。对于A、B、C和D的每一个值，我们都要取两个值，然后取其平均值。这些平均值仍然以速度为单位，因为它们只是两个速度值的均值。"

#: ../source/docs/software-info-team1684/swerve-in-auton/the-math.rst:69
#: 576c8099ea3b4f47999b68b810760201
msgid ""
"A = (A_{RR} + A_{RL})/2\n"
"\n"
msgstr ""
"A = (A_{RR} + A_{RL})/2\n"
"\n"

#: ../source/docs/software-info-team1684/swerve-in-auton/the-math.rst:70
#: 2750cb969e32482692f0971a9d592e24
msgid ""
"B = (B_{FL} + A_{FR})/2\n"
"\n"
msgstr ""
"B = (B_{FL} + A_{FR})/2\n"
"\n"

#: ../source/docs/software-info-team1684/swerve-in-auton/the-math.rst:71
#: 9b8f9dc0feae4ce18c6078f52a33f274
msgid ""
"C = (C_{FR} + C_{RR})/2\n"
"\n"
msgstr ""
"C = (C_{FR} + C_{RR})/2\n"
"\n"

#: ../source/docs/software-info-team1684/swerve-in-auton/the-math.rst:72
#: 4b040a9b33f948a3a9402808ce91eda6
msgid ""
"D = (D_{FL} + D_{RL})/2\n"
"\n"
msgstr ""
"D = (D_{FL} + D_{RL})/2\n"
"\n"

#: ../source/docs/software-info-team1684/swerve-in-auton/the-math.rst:74
#: 07a0c93b6add48dbb2c956c20ff129c4
msgid ""
"Excellent, that's brought our complexity down some. Now we need to find our "
"rotational velocity, or ROT. For this, we need physically accurate "
"measurements of what we earlier defined as the length and width of our "
"wheelbase, L and W. Then, we'll calculate the possible rotational velocity "
"from our knowledge about the front/back (A/B) and left/right (C/D) "
"velocities, and average those again to get a single value. Note that it's "
"also possible to get this ROT value (which should be in radians/second) from"
" a gyroscope, which we should already have on our robot so we can drive "
"field-centric."
msgstr ""
"很好，我们终于把我们的复杂度降下来了。现在我们需要找到我们的旋转速度，或ROT。然后，我们将根据机器前后（A/B）和左右（C/D）速度的值，计算出可能的旋转速度，并再次取平均值，得到一个单一的值。请注意，我们也可以从陀螺仪上得到这个ROT值（单位是弧度/秒），我们的机器人上应该已经有了这个陀螺仪，使得我们可以以场地为中心进行驱动。"

#: ../source/docs/software-info-team1684/swerve-in-auton/the-math.rst:81
#: da840c30f9fd4e538fe487e5d23b9546
msgid ""
"ROT_{1} = (B − A)/L\n"
"\n"
msgstr ""
"ROT_{1} = (B − A)/L\n"
"\n"

#: ../source/docs/software-info-team1684/swerve-in-auton/the-math.rst:82
#: dfeb5379a18e46aead921caf1d004ea9
msgid ""
"ROT_{2} = (C − D)/W\n"
"\n"
msgstr ""
"ROT_{2} = (C − D)/W\n"
"\n"

#: ../source/docs/software-info-team1684/swerve-in-auton/the-math.rst:83
#: d472d6f55eeb40eb9c6f56dd042f7b22
msgid ""
"ROT = (ROT_{1} + ROT_{2})/2\n"
"\n"
msgstr ""
"ROT = (ROT_{1} + ROT_{2})/2\n"
"\n"

#: ../source/docs/software-info-team1684/swerve-in-auton/the-math.rst:85
#: f97d004a1a234d19bf85a56ca8164aae
msgid ""
"From here, we're simply going to incorporate this with our geometry and A, "
"B, C, D values to obtain (again) two values each for forward and strafe "
"velocities, and average them to get our final estimates of forward and "
"strafe speed."
msgstr ""
"在此，我们将简单地将这与我们的几何学和A、B、C、D值结合起来，以（再次）获得前后和左右移动的的两个值，并取其平均值，以获得我们对向前和扫射速度的最终估计。"

#: ../source/docs/software-info-team1684/swerve-in-auton/the-math.rst:89
#: 2db54a59e91e432da09b1859f463e67c
msgid ""
"FWD_{1} = ROT * (L/2) + A\n"
"\n"
msgstr ""
"FWD_{1} = ROT * (L/2) + A\n"
"\n"

#: ../source/docs/software-info-team1684/swerve-in-auton/the-math.rst:90
#: 30a9fb40240f4f0e84c7bbef3f1541fd
msgid ""
"FWD_{2} = − ROT * (L/2) + B\n"
"\n"
msgstr ""
"FWD_{2} = − ROT * (L/2) + B\n"
"\n"

#: ../source/docs/software-info-team1684/swerve-in-auton/the-math.rst:91
#: 7b2782ac2c084b48af25e2b84f8fef36
msgid ""
"FWD = (FWD_{1} + FWD_{2})/2\n"
"\n"
msgstr ""
"FWD = (FWD_{1} + FWD_{2})/2\n"
"\n"

#: ../source/docs/software-info-team1684/swerve-in-auton/the-math.rst:93
#: 96b1f772a8504e9bb6bc8f8243238c7c
msgid ""
"STR_{1} = ROT * (W/2) + C\n"
"\n"
msgstr ""
"STR_{1} = ROT * (W/2) + C\n"
"\n"

#: ../source/docs/software-info-team1684/swerve-in-auton/the-math.rst:94
#: 4cfd0d8c0de440f6bda3a07eccb129c2
msgid ""
"STR_{2} = − ROT * (W/2) + D\n"
"\n"
msgstr ""
"STR_{2} = − ROT * (W/2) + D\n"
"\n"

#: ../source/docs/software-info-team1684/swerve-in-auton/the-math.rst:95
#: 3515c948ebe645faae4ad99637e3568c
msgid ""
"STR = (STR_{1} + STR_{2})/2\n"
"\n"
msgstr ""
"STR = (STR_{1} + STR_{2})/2\n"
"\n"

#: ../source/docs/software-info-team1684/swerve-in-auton/the-math.rst:97
#: 99cf543abe1f494ab5af88a23cc225f0
msgid ""
"Great! Now we've got something to work with. If we want our distance values "
"to be usefu l, though, these velocities should be transformed so they're "
"field-centric. Back to our trusty field centric transformation, we'll again "
"need our angle relative to the field, usually provided by a gyroscope."
msgstr ""
"太好了! "
"现在终于又可以用的数据了。不过，如果我们希望我们的距离值真正可用，这些速度应该被转换为以场地为中心的。为了再把数据变换为我们可靠的以场地为中心的数据，我们将再次需要相对于场地的角度，通常由陀螺仪提供。"

#: ../source/docs/software-info-team1684/swerve-in-auton/the-math.rst:101
#: b0f09bee8b0e459db3af353cb4125512
msgid ""
"FWD_{new} = FWD * cos(θ) + STR * sin(θ)\n"
"\n"
msgstr ""
"FWD_{new} = FWD * cos(θ) + STR * sin(θ)\n"
"\n"

#: ../source/docs/software-info-team1684/swerve-in-auton/the-math.rst:102
#: 7f5504f917e14e42984048d940795410
msgid ""
"STR_{new} = STR * cos(θ) − FWD * sin(θ)\n"
"\n"
msgstr ""
"STR_{new} = STR * cos(θ) − FWD * sin(θ)\n"
"\n"

#: ../source/docs/software-info-team1684/swerve-in-auton/the-math.rst:105
#: 817ddb8beee4444f9a198df083187259
msgid "Odometry"
msgstr "里程表"

#: ../source/docs/software-info-team1684/swerve-in-auton/the-math.rst:106
#: 0a0663e71ab84cacb1f14129ed78e827
msgid ""
"From there, we can now figure out how fast we're actually going along the "
"field - pretty nifty! To get to a position, we just need to integrate these "
"over time. This is as simple as initializing a timer and comparing its value"
" at the current loop run to its value in the previous run to determine our "
"timestep . For most robot code, this timestep is somewhere around 0.020 "
"seconds, or 20 milliseconds; however, this is only a nominal value, and it "
"can vary up and down (mostly up) depending on the behavior of the robot's "
"code. In any case, we can take this timestep and our speed and integrate it "
"into an accumulator value to get our position relative to where we started "
"counting."
msgstr ""
"由此，我们现在可以算出我们实际上是以多快的速度沿着场地前进的——相当巧妙！我们可以把这些数据整合到一起。为了得到一个位置，我们只需要在时间上整合这些数据。这就像初始化一个定时器，并将其在当前循环运行时的值与上一次运行时的值相比较，以确定我们的循环的时间间隔也很简单。对于大多数机器人代码来说，这个值一般约为0.020秒，或20毫秒；然而，这只是一个名义上的数值，它可以根据机器人代码的行为而上下变化（主要是上升）。无论如何，我们总是可以把这个值和我们的速度整合到一个累加器中，以得到我们相对于开始记录时的位置。"

#: ../source/docs/software-info-team1684/swerve-in-auton/the-math.rst:120
#: 0c0e754accae4363b1a05da2b2f59ba2
msgid ""
"We're calling our axis associated with strafing along and our axis "
"associated with moving forward or back across. This turned out to facilitate"
" communication within our team more easily than axis conventions like x/y/z."
msgstr "顺带一提，我们用前后和左右来称呼我们的各个方向，这可比xyz轴易于沟通多了"

#: ../source/docs/software-info-team1684/swerve-in-auton/the-math.rst:124
#: 9e81b72e663b4ebf91bfd757da099b6b
msgid ""
"We now have our odometry. When using it in autonomous routines, we reset "
"this value to zero at the start, and consider our coordinates relative to "
"where the robot starts. This means robot positioning is very important, as "
"any error will be carried through the odometry."
msgstr ""
"我们现在有了我们的里程表。当在自动时段中使用它时，我们在开始时将这个值重置为零，并将我们程序内的坐标与机器人开始的位置相对应。这意味着机器人的初始位置拜访是非常重要的，因为任何误差都会通过里程表来体现。"

#: ../source/docs/software-info-team1684/swerve-in-auton/the-math.rst:128
#: 0759cd2f0aea44bc9e00028a8c8a163a
msgid ""
"When you add the change every cycle, you always know where that wheel is. "
"The same is done for the other 3 wheels. We use that information to find the"
" center of the robot. The direction that the robot is facing could also be "
"determined in the same manner, but we chose to use our gyros for that. We "
"only store the current position of the center of the robot. We do , however,"
" send that position to the dashboard and record the data there. We are able "
"to graph out the position that the robot reported and impose it over a map "
"of the field to allow us to make improvements to our autons even without "
"having access to the robot."
msgstr ""
"当你在每个周期添加变化时，你总是知道某个轮子的位置，对另外3个也是。我们用这些信息来定位机器人的中心。机器人的方向也可以用同样的方式来确定，但我们选择用我们的陀螺仪来做这个。我们只存储机器人中心的当前位置。我们将该位置发送到Dashboard，并在那里记录数据。我们能够据此绘制出机器人的位置图，并将其画在在场地地图上，使我们能够在不接触机器人的情况下对我们的自动进行改进。"

#: ../source/docs/software-info-team1684/swerve-in-auton/the-math.rst:136
#: 4894dfb62c4e4516af9cb0c5f92b7e13
msgid ""
"The next part of the puzzle is to tell the robot where to go next. We "
"reverse the tracking process to instruct each wheel on where to go next. We "
"input the desired x,y coordinate into the subroutine. The angle that each "
"wheel needs to face is calculated. The angle will be the same for all wheels"
" unless the robot is going to spin while moving. If the robot will be "
"changing heading while moving, the amount of turn correction will be "
"factored in causing the wheels to face different directions and have "
"different relative speeds until the spin portion is achieved. We use a "
"positioning loop to assign the wheel speed. We are only using kP * error. We"
" can change states by several different criteria. We might use an achieved "
"distance, an intake sensor, or a targeting feedback to tell the robot that "
"it is done with that task. The robot then moves on to the next task."
msgstr ""
"下一个问题是告诉机器人接下来要怎么走。我们把跟踪过程倒过来，告诉每个轮子下一步要去哪里。我们在子系统中输入所需的x、y坐标。每个轮子需要面对的角度被计算出来。除非机器人在移动时要旋转，否则所有车轮的角度都是一样的。如果机器人将在移动中改变航向，那么转弯修正量将被计入，并使得车轮面对不同的方向，并有不同的相对速度，直到实现旋转部分。我们使用一个定位循环来分配车轮的速度。我们只使用kP*误差。我们可以通过几个不同的标准来改变状态。我们可能会使用已实现的距离、intake传感器或瞄准反馈来告诉机器人，它已经完成了该任务。然后，机器人就会转到下一个任务。"

#: ../source/docs/software-info-team1684/swerve-in-auton/the-math.rst:147
#: a9267b525bab4f3d94d12bb463a96a0a
msgid "Calibration"
msgstr "校准"

#: ../source/docs/software-info-team1684/swerve-in-auton/the-math.rst:148
#: 53b750fd4eda473aa33b7380b131db46
msgid ""
"If we used our nominal wheel diameters and gear ratios, these values should "
"be pretty close to real-world values, but they probably won't be perfect. "
"We'll want to calibrate our overall speeds by applying a multiplier. This "
"calibration can be as simple as marking off a set distance (the longer the "
"better) and driving the robot across this distance, keeping it as straight "
"as possible. Once the distance is reached, the reported distance value can "
"be compared with the actual distance value and ratioed to produce a "
"correction factor - actual distance over reported distance. This can also be"
" used to account for wheel wear, which changes the effective wheel diameter "
"and can cause inaccurate distance measurements when not accounted for."
msgstr ""
"如果我们使用我们的理想车轮直径和齿轮比，这些数值应该非常接近真实世界的数值，但它们可能并不完美。我们要通过乘上一个常数来校准我们的整体速度。这种校准可以很简单，就是标出一个设定的距离（越长越好），然后驾驶机器人穿过这个距离，尽可能保持直线。一旦达到这个距离，就可以将报告的距离值与实际距离值进行比较，并将其比值产生一个修正系数"
"--实际距离大于报告距离。这也可以用来计算车轮的磨损，车轮的磨损会改变有效的车轮直径，如果不计算在内，会导致距离测量不准确。"
