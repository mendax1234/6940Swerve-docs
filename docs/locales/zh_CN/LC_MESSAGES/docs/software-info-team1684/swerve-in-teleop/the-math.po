# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2022, Daniel Webber (mendax1234)
# This file is distributed under the same license as the 6940 Swerve package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Daniel Webber, 2022
# zhang jiaming, 2022
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: 6940 Swerve\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-07-30 20:18+0000\n"
"PO-Revision-Date: 2022-07-04 16:26+0000\n"
"Last-Translator: zhang jiaming, 2022\n"
"Language-Team: Chinese (China) (https://www.transifex.com/frc-team-6940-1/teams/135321/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:2
#: 21d61fd6d8a6427b99805547a5cc243b
msgid "The Maths"
msgstr "数学部分"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:5
#: 59954294b1494d86b55343a5ed42a535
msgid "Controls and Inputs"
msgstr "控制与输入处理"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:7
#: 206560ea8aba403fa3b0a390ad2adce3
msgid ""
"The driver has some intended output that they'd like the robot to do. In "
"order to communicate this, we define three command inputs - Forward, Strafe,"
" and Rotation, or :math:`FWD`, :math:`STR`, and ROT. Let's define these as "
"variables, each going from -1 to 1, with 0 indicating no control input. "
"There are many ways to map driver inputs to these commands via joysticks, "
"but we chose to use a method where one stick controls translation rate (FWD "
"and :math:`STR`) and the other's left-right axis controls rotation rate "
"(ROT), as shown on the controller. These joysticks are implemented using "
"standard libraries in WPILib, and input is filtered and transformed to "
"provide a better experience to the drivers. In addition to the driver's "
"inputs, we can have inputs incorporated."
msgstr ""
"在操纵时，driver希望机器人可以按照他们的想法行动，而为了将driver的想法与实际程序联系起来，我们定义了三个输入变量，:math:`FWD`, "
":math:`STR`, 与 "
":math:`ROT`，它们的取值范围是-1到1。其中，0代表没有输入数据的情况。有许多方法来将driver的输入映射到该范围中。而在本案例中，我们决定用一个摇杆来控制移动速率（即:math:`FWD`与:math:`STR`），另一个摇杆来控制旋转速率（即ROT）。如图所示。这些摇杆采用WPILib的标准库实现，输入经过筛选和变换以便于driver使用。除了driver的输入变量，我们也可以把别的输入变量纳入考虑。"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:20
#: 367439a7950c4dd4b4ca24ba29f50448
msgid "In addition to the driver's inputs, we can have inputs incorporated."
msgstr "除了driver的输入变量，我们也可以把别的输入变量纳入考虑。"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:23
#: d2be0b4be89a4b968ff96a463349ae59
msgid "Field Centric Transformation"
msgstr "以场地为参照系的数据变换"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:25
#: 412ec0f5a2e245c78b404904e53479c4
msgid ""
"Once we know the intended movement that the robot should be making, we "
"should apply our field-centric math. This is what's known as a "
"transformation . In simple terms, we take what we know about the robot's "
"orientation relative to the field - in this case, its angle (as measured by "
"a gyroscope) and our known desired forward/back and strafe commands, and "
"adjust them so that the robot moves relative to the field."
msgstr ""
"一旦我们确定了:math:`FWD`, :math:`STR`, 与 "
":math:`ROT`的值。我们就要对这些数据进行一些数学变换。简单来说，我们要将以场地为参照系的数据，基于机器人与场地的夹角（由陀螺仪测得），变换为以机器人为参照系的数据，进而使机器人以场地为参照系移动。"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:31
#: 65ebf1752b114e41b46955ecfc931af1
msgid ""
"We define :math:`FWD` and :math:`STR` as the desired forward/back and strafe"
" commands from the joystick, relative to the field. These can both range "
"from -1 to 1 from the joystick, assuming things are filtered correctly, and "
"the magnitude of the input vector (:math:`FWD`, :math:`STR`) shouldn't ever "
"be greater than 1. We'll find that this doesn't matter later."
msgstr ""
"我们定义 :math:`FWD` and "
":math:`STR为我们所预期的、来自摇杆的平移指令。它们的取值在1到-1之间，我们假设它们都被正确地过滤。同时两者（作为向量）的和向量的模不应大于1，但晚些时候我们会发现这并不重要。"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:36
#: 36535fcf04af4ef4b0968cdf38da292a
msgid ""
"We'll call the angle of the chassis relative to the field θ, and assume that"
" it's 0 when the front of the robot is aligned with the field, away from the"
" driver. This angle can be either defined from -180° to 180°, or from 0 to "
"360 degrees - the math in this case works the same. With these in mind, we "
"can transform our :math:`FWD` and :math:`STR` commands as follows:"
msgstr ""
"我们定义机器人与场地的夹角为θ，当机器人的正面与场地的边框相平行，远离驾驶员时，θ的数值为0。该角度的取值范围既可以是0-360°，也可以是-180°到180°——在该案例中进行数学运算时，两者并无实际区别。进一步地，我们可以将:math:`FWD`与:math:`STR`作如下变换："

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:41
#: 7115b00488fc4b42b6485934de0ca6d0
msgid ""
"FWDnew = FWD * cosθ + STR * sinθ\n"
"\n"
msgstr ""
"FWDnew = FWD * cosθ + STR * sinθ\n"
"\n"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:42
#: 59c7edcefc8e4c7d9dcbf1b7976aca08
msgid ""
"STRnew = STR * cosθ − FWD * sinθ\n"
"\n"
msgstr ""
"STRnew = STR * cosθ − FWD * sinθ\n"
"\n"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:51
#: 53b3858aa5b04c58a1c9bfaa7d9fff8e
msgid ""
"To explain this further, let's look at the results of the the following "
"three situations:"
msgstr "为了进一步深化对这两个式子的理解，让我们来看看下面的几个例子。"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:53
#: 897f434360424997b2efd1964f6348b9
msgid "**Example 1: Robot is aligned with field**"
msgstr "**例子1：机器人与场地对齐**"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:55
#: f773b803e2a7452e818c8a692d5c1333
msgid ""
"The key here is to think about what the value of θ is, and how the value of "
"our sines and cosines changes as a result. Here, since we're aligned with "
"the field, :math:`θ=0°`. Let's check our sine and cosine plots to see where "
"that puts us at, in terms of values:"
msgstr ""
"这里的关键是思考θ的值是多少，以及我们的正弦和余弦的值如何随之而变化。在这里，由于我们是与场地对齐的，:math:`θ=0°`。让我们来看看我们的正弦和余函数图像。"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:63
#: 94faed4f301f45b9988b2d569cdcd00b
msgid ""
":math:`cos0°` is 1, and :math:`sin0°` is 0. If we think about a right "
"triangle, with one of its angles being 0° and a hypotenuse of 1, the "
"opposing side of that triangle would have no height - and the adjacent side "
"would have the length of the hypotenuse, or 1. Let's see what our math does "
"with this."
msgstr ""
"如果我们想象一个直角三角形，其中一个角是0°，斜边是1，那么这个三角形的对边就没有高度也就是0--"
"同时邻边就有斜边的长度，也就是1。让我们看看我们的式子的处理结果。"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:67
#: 7bd9b32309bb4be8adb1c898b0cb3e56
msgid ""
"FWD_{new} = FWD * cos(0°) + STR * sin(0°) = FWD * 1 + STR * 0 = FWD\n"
"\n"
msgstr ""
"FWD_{new} = FWD * cos(0°) + STR * sin(0°) = FWD * 1 + STR * 0 = FWD\n"
"\n"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:68
#: a7720cbb5d914eb6a340d9dd3edda6e1
msgid ""
"STR_{new} = STR * cos(0°) − FWD * sin(0°) = STR * 1 − FWD * 0 = STR\n"
"\n"
msgstr ""
"STR_{new} = STR * cos(0°) − FWD * sin(0°) = STR * 1 − FWD * 0 = STR\n"
"\n"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:70
#: 129ebfe602cc4221a86463cb98c1775c
msgid ""
"Our math tells us that we haven't changed anything by doing this! "
"Physically, this makes sense; if the robot is aligned with the field, what "
"it considers to be forward is the same as the field's forward; we don't need"
" to modify our commands at all."
msgstr ""
"我们的式子告诉我们，我们并不需要改变任何东西! 事实上，这是有道理的；如果机器人与场地对齐，它的前方与场地的前方是一样的；我们根本不需要修改我们的指令。"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:74
#: c3616a6a36bc4744a149d21b5751e5a8
msgid "**Example 2: Robot is at 90 degrees to field**"
msgstr "**例子2：机器人与场地呈90度**"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:76
#: 01434eff50f1450d9de7edc6a1825b52
msgid ""
"Let's say that we're now at a right angle to the field; our robot is "
"sideways, so our angle :math:`θ=90°`. Again, let's check our trigonometry. "
":math:`cos90°` = 0, and :math:`sin90°` = 1. What does our math do with "
"these?"
msgstr ""
"假设我们的机器人与场地成直角，即机器人是侧向的，所以我们的角度:math:`θ=90°`。让我们再看看三角函数的结果。 :math:`cos90°` ="
" 0, :math:`sin90°` = 1. 再让我们看看式子的处理结果。"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:80
#: b4dbd954987a48d7afc62f9a2b3e38c0
msgid ""
"FWD_{new} = FWD * cos(90°) + STR * sin(90°) = FWD * 0 + STR * 1 = STR\n"
"\n"
msgstr ""
"FWD_{new} = FWD * cos(90°) + STR * sin(90°) = FWD * 0 + STR * 1 = STR\n"
"\n"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:81
#: 2e1411e8c60f4aaf8404981503e9836a
msgid ""
"STR_{new} = STR * cos(90°) − FWD * sin(90°) = STR * 0 − FWD * 1 = −FWD\n"
"\n"
msgstr ""
"STR_{new} = STR * cos(90°) − FWD * sin(90°) = STR * 0 − FWD * 1 = −FWD\n"
"\n"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:83
#: 9c053a1675df4ed6bdbdc1384b33c544
msgid ""
"Our commands have switched (with a small change of sign)! Again, physically,"
" this makes some sense. The robot is sideways; in order to go forward, it "
"has to do what it considers a strafe, and in order to strafe, it has to go "
"what it considers forward."
msgstr ""
"我们的指令被变换了（并且符号有一个小的变化）！事实上，这也是有道理的。机器人是侧向的；为了向前走，它必须做它认为的横向移动，而为了横向移动，它必须走它认为的前进。"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:87
#: 66606536257e437e9aeaedfa2586225c
msgid "**Example 3: Robot is at 30 degrees to field**"
msgstr "**例子3：机器人与场地呈30度**"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:89
#: 64655f7622c14c498abb31ee1c007e10
msgid ""
"We're now at some angle that doesn't produce as nice a result. The robot is "
"aligned differently from the field, so to go straight forward or straight "
"sideways, the robot is going to need to do some combination of what it "
"considers going forward and going sideways. With our angle θ=30°, "
":math:`cos30°` = 0.866, and :math:`sin30°` = 0.5. Following through the "
"equations, then,"
msgstr ""
"我们现在的这个角度并不是很易于想象。机器人的排列方式与场地不同，所以要想直接向前或直接向侧边走。我们需要进行一些比较复杂的数学变换。我们的角度θ=30°，"
" :math:`cos30°` = 0.866, :math:`sin30°` = 0.5. 顺着式子走，那么："

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:93
#: c62756c406c4498cbb91a6763f17ee56
msgid ""
"FWD_{new} = FWD * cos(30°) + STR * sin(30°) = FWD * 0.866 + STR * 0.5\n"
"\n"
msgstr ""
"FWD_{new} = FWD * cos(30°) + STR * sin(30°) = FWD * 0.866 + STR * 0.5\n"
"\n"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:94
#: 62489a88ab9d49d3926de96721a76622
msgid ""
"STR_{new} = STR * cos(30°) − FWD * sin(30°) = STR * 0.866 − FWD * 0.5\n"
"\n"
msgstr ""
"STR_{new} = STR * cos(30°) − FWD * sin(30°) = STR * 0.866 − FWD * 0.5\n"
"\n"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:96
#: 940f21f3d8f4408c9bfc538e2dadc97f
msgid ""
"Both :math:`FWD` and :math:`STR` contribute to each of the transformed "
"values. This pattern will carry through for any non-right angle, and as long"
" as we consider our angle properly (with clockwise as positive) we're good "
"to go!"
msgstr ""
":math:`FWD`和:math:`STR`都对每个转换值有贡献。这种计算方式，将贯穿于任何非直角的运算，而只要我们正确地计算我们的角度（顺时针为正），就可以得到正确的运算结果了！"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:101
#: e92ebdc945454dac92abd72c8260d4e8
msgid "Inverse Kinematics (Wheel Speeds and Azimuths)"
msgstr "逆向运动学（计算轮子转速与朝向）"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:103
#: 1e74676754fe49ae8994b6787270320a
msgid ""
"Now that we have our :math:`FWD` and :math:`STR` commands transformed, we "
"need to figure out what each wheel should be doing to execute them. What "
"we're doing here is commonly referred to as `inverse kinematics "
"<https://en.wikipedia.org/wiki/Inverse_kinematics>`_ , or IK. We have some "
"goal output we want to get to, and we have some actuator parameters (or "
"joints) we can adjust, those being our wheel speeds and azimuth angles. "
"Inverse kinematics is the calculation of a unique set of output settings "
"that will give us our overall output. Forward kinematics (which we'll cover "
"elsewhere) is the opposite - determining the state (or pose) we're in based "
"on what our actuators have been doing."
msgstr ""
"现在我们的:math:`FWD`与:math:`STR` "
"都已经被正确转换了。我们接着需要算出每一个轮子的运动参数。这一段的内容通常被称为`inverse kinematics "
"<https://en.wikipedia.org/wiki/Inverse_kinematics>`_，简称IK。我们有我们想要达到的目标输出，以及可以调整的执行器参数（也称作关节），即我们的车轮速度和朝向。逆向运动学的本质计算一组独特的输出数据，从而得到我们的整体目标输出。正向运动学（我们将在其他地方介绍）与此相反"
"--根据我们的执行器在做的事情来确定我们所处的状态（即姿态）。"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:111
#: 58f7b6b2b5ce4b8dbb8892944d37a349
msgid ""
"First, we should account for the wheel layout. We're going to assume our "
"wheel pods are on the vertices of a rectangle. To put it another way, all "
"four wheel axles are able to lie on some circle. This represents the "
"majority of swerve drive setups (ours was square). If the swerve modules are"
" not on a square (e.g. if the robot is not square), we'll account for that "
"as we make our calculations."
msgstr ""
"首先，我们应该考虑到车轮的布局。我们将假设我们的车轮位于一个矩形的顶点上。换句话说，所有四个轮轴都能处在某个圆上。这代表了大多数swerve驱动的底盘的样子（我们的就是方形）。如果swerve模块不在一个矩形上（例如，如果机器人不是矩形），我们将在计算时考虑到这一点。"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:116
#: 2b464b128a5045ce9bf867abcc10416b
msgid ""
"First, let's define the length and width of our wheelbase as L and W, and "
"let's define an additional value :math:`R`, as :math:`R = \\sqrt{L^2 + W^2}`"
" , or the diameter of the circle that contacts all four wheel axles. The "
"units of these values don't matter, as we're only going to be taking their "
"ratios in our wheel calculations."
msgstr ""
"接着，让我们把轴距的长度和宽度定义为L和W，同时，我们定义一个额外的值 :math:`R`, 其值为 :math:`R = sqrt{L^2 + "
"W^2}`, 代表接触所有四个轮轴的圆的直径。这些值的单位并不重要，因为我们在计算车轮的时候只需要它们的比值。"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:127
#: d1daf341821c48749240fdb884471849
msgid "Intuition"
msgstr "理想模型"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:128
#: 6cfcb6e92ff446569c17a8f2da82c5f5
msgid ""
"To understand how we can turn our overall commands (what we want the robot "
"as a whole to do) into what each wheel needs to do, we should build some "
"intuition. It's perfectly possible to borrow the math and program it into "
"place without this, but it really helps to understand how things work under "
"the hood."
msgstr ""
"为了知道如何将我们的对于机器人整体的指令（我们希望机器人作为一个整体做什么）转化为每个轮子的指令，我们应该建立一些理想模型。即使我们不这样做，我们也完全可以借用数学知识并将其编程到位，但这确实有助于了解代码的工作原理。"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:133
#: 2628de6266cb47269f7897baf1a33abe
msgid ""
"As we derive our inverse kinematics, we make some underlying assumptions, "
"including that the robot's chassis acts as a rigid body - within its own "
"reference frame, one point cannot move closer or further away to another "
"point. Imagine a metal cube on a desk. You can move it forward, back, and "
"spin it, but it's solid and unchanging relative to itself. From a kinematics"
" standpoint, there's an important fact we can draw from this. If we look at "
"one side of the robot, all points along it have to have the same velocity "
"forward or backward. If they had different speeds, the side would be "
"changing in length. Hopefully that's not actually happening, and if our "
"robot is built sufficiently rigidly, it shouldn't be."
msgstr ""
"当我们推导反运动学时，我们建立了一个理想模型，我们将机器人的底盘视作一个刚体——在其自身的参照系内，一个点不能靠近或远离另一个点。想象一下，桌子上有一个金属立方体。你可以向前、向后移动它，也可以旋转它，但它是刚体，它的形状是不变的。从物理学的角度来看，我们可以推导出一个重要的结论。对于机器人的每一条边，它上面的所有点都必须具有相同的向前或向后的速度。如果它们有不同的速度，那么这个侧面的长度就会发生变化。真希望这种情况不会发生在赛场上，如果我们的代码写得足够好，就不应该发生这种情况。"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:146
#: 2d3fca5221444d8c904587b996f2eda2
msgid ""
"We can back this assumption out by doing some vector math . ChiefDelphi user"
" Ether's `Derivation of Inverse Kinematics for Swerve "
"<https://www.chiefdelphi.com/t/paper-4-wheel-independent-drive-independent-"
"steering-swerve/107383>`_ document explains this in detail. To do this, we "
"can combine our desired strafe and speed commands into a translation vector "
", and our rotation command can be combined with our robot geometry to form a"
" rotational component. By adding these vectors, we get our required wheel "
"movement vector, in the form of a direction and a magnitude."
msgstr ""
"我们可以通过做一些向量运算来满足这一点。ChiefDelphi用户Ether的`Derivation of Inverse Kinematics for"
" Swerve <https://www.chiefdelphi.com/t/paper-4-wheel-independent-drive-"
"independent-steering-"
"swerve/107383>`_文件详细解释了这一点。要做到这一点，我们可以将我们所需的横向运动和前后运动指令合并为一个平移矢量，而我们的旋转指令可以与我们的机器人几何形状相结合，形成一个旋转分量。通过添加这些矢量，我们可以得到我们所需的车轮运动矢量，其形式为朝向和转速。"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:153
#: 1018e92e98ac41e7a2284ccb2711fab4
msgid ""
"From here, we'll define some variables to save us some work. Standard "
"convention has them as A, B, C, and D."
msgstr "在此，我们定义一些变量来节省我们的工作量。一般我们把它们定义作A、B、C与D。具体定义式如下："

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:156
#: cf4eefdff3a74185abbcb1888f0fa4b1
msgid ""
"A = STR - ROT * L/R\n"
"\n"
msgstr ""
"A = STR - ROT * L/R\n"
"\n"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:157
#: 4b25df224ee845cea703a86b46e77bf8
msgid ""
"B = STR + ROT * L/R\n"
"\n"
msgstr ""
"B = STR + ROT * L/R\n"
"\n"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:158
#: 9d6f9086e2e54f7ba3f0e86a703c3e17
msgid ""
"C = FWD - ROT * W/R\n"
"\n"
msgstr ""
"C = FWD - ROT * W/R\n"
"\n"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:159
#: 06f38cf3512f4642846a922e321145ac
msgid ""
"D = FWD - ROT * W/R\n"
"\n"
msgstr ""
"D = FWD - ROT * W/R\n"
"\n"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:161
#: 97428c2c22ef4f2d92217c1d7e7d97aa
msgid ""
"We'll use these to calculate our resultant wheel speeds and wheel angles (or"
" azimuth angles), or ws and wa respectively."
msgstr "我们运用这些数值来计算我们各个轮子的转速与朝向（即wheel speed 与wheel angles，下式中简写为Ws与Wa）"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:164
#: 0c5403425f7f4499aaf07e3d256c64f4
msgid ""
"ws_{FR} = \\sqrt{B^2 + C^2}\n"
"\n"
msgstr ""
"ws_{FR} = \\sqrt{B^2 + C^2}\n"
"\n"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:165
#: 07c6df8faf1f4a6ebf421b0d12b57d23
msgid ""
"wa_{FR} = atan2(B,C)\n"
"\n"
msgstr ""
"wa_{FR} = atan2(B,C)\n"
"\n"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:166
#: dfd2e4d3efdf4c1abf77a72948eab2c1
msgid ""
"ws_{FL} = \\sqrt{B^2 + D^2}\n"
"\n"
msgstr ""
"ws_{FL} = \\sqrt{B^2 + D^2}\n"
"\n"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:167
#: ba40f94ef3b44530a28b2b86ee72c788
msgid ""
"wa_{FL} = atan2(B,D)\n"
"\n"
msgstr ""
"wa_{FL} = atan2(B,D)\n"
"\n"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:168
#: 6b8e8e906cd3460484c367086db9f00a
msgid ""
"ws_{RR} = \\sqrt{A^2 + C^2}\n"
"\n"
msgstr ""
"ws_{RR} = \\sqrt{A^2 + C^2}\n"
"\n"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:169
#: 88d18958569f41e491d8ade1c1afc310
msgid ""
"wa_{RR} = atan2(A,C)\n"
"\n"
msgstr ""
"wa_{RR} = atan2(A,C)\n"
"\n"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:170
#: b6fa0212289846c19f84f5db6fa95e91
msgid ""
"ws_{RL} = \\sqrt{A^2 + D^2}\n"
"\n"
msgstr ""
"ws_{RL} = \\sqrt{A^2 + D^2}\n"
"\n"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:171
#: 16c0576eb2de43d8b2c25694eddef31d
msgid ""
"wa_{RL} = atan2(A,D)\n"
"\n"
msgstr ""
"wa_{RL} = atan2(A,D)\n"
"\n"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:173
#: c397ac3b700d45ad99662c889a7e5346
msgid ""
"The atan2 function is defined in many programming languages, and provides "
"quadrant-aware calculations for the arctangent function, meaning the angle "
"output will range from -π to π, instead of 0 to π/2."
msgstr ""
"此处，atan2函数是一个在许多语言中都被定义的函数，它的返回值是括号内两数之比的arctan值。值得一提的是，它的返回值是 -π 到 π 而不是0 到"
" π/2。"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:175
#: 623d87c9441e41cc9e3a8a081599fd32
msgid ""
"What we see here is that we have common factors between our wheels. For both"
" front wheels, we have a common horizontal factor B, and for both rear "
"wheels, a different common factor A. For both right wheels, and left, we see"
" the same thing, with common forward/backward components C and D. This is "
"the mathematical realization of the fact that our robot's chassis can't "
"change in size or shape. Bonus: if you know a bit of vector math, you'll "
"notice that we're doing a transformation from cartesian to polar "
"coordinates."
msgstr ""
"在此，我们可以看到，不同的车轮之间有共同的因子。对于两个前轮，我们有一个共同的水平因子B，对于两个后轮，有一个共同因子A。对于两个右轮和左轮，同样地，有共同的前后移动分量C和D。如果你知道一点向量知识，你会意识到我们实际上做了一个从平面直角坐标到极坐标的转换。"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:182
#: a16c10401f7c49bfa45c5c528b816b89
msgid ""
"Where FR, FL, RR, and RL refer to front right, front left, rear right, and "
"rear left wheels. Our azimuth angles should range from -π to π, with "
"positive as clockwise and zero being straight π π ahead. These can be "
"converted to degrees as necessary - just multiply by 180/π . Our wheel "
"speeds should range from 0 to 1, absolute, but we'll need to check if they "
"need to be normalized. To do this, we just check if the maximum of our ws "
"values is greater than 1, and if it is, scale the values such that it's 1."
msgstr ""
"其中FR、FL、RR和RL指的是右前、左前、右后和左后轮。我们的算得的朝向的数值是从-"
"π到π，正数为顺时针方向，零为直行。这些可以根据需要转换为度数——只要乘以180/π。我们的轮速的绝对值应该在0到1之间。为此，我们只需检查我们的ws值的最大值是否大于1，如果是，就将这些值按比例放缩，使ws的最大值为1。"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:197
#: 552dc6f44b02452d85ecd70158cf5d95
msgid ""
"Now we have all ws values ranging from 0 to 1. The wheel speed assumed to be"
" in the direction the wheel is facing ( wa ), and thus does not go negative,"
" as that would imply the wheel has turned 180°."
msgstr "现在，我们算出了所有的ws值，范围从0到1。ws的值不应为负数，因为这意味着轮子的朝向（即wa）值应当再转180°"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:200
#: 69e5eedd58c246948fcc80e664672ea7
msgid ""
"Our algorithm to this point brings up a problem. If our control input "
"quickly changes from, for example, moving entirely forward to moving "
"backward, our wheel pods need to turn all the way around in order to execute"
" the new command. Given that we're working with motors that can go full "
"power forward or backward, that's an inefficient thing to do. Ideally, we'd "
"just flip the motor into reverse and move on."
msgstr ""
"但现在，我们的算法带来了一个问题。 如果我们的控制输入快速从全速向前变为全速向后移动，我们的轮舱需要旋转180°才能执行新命令。 "
"鉴于我们正在使用可以全功率前进或后退的电机，这是一件低效的事情。 理想情况下，我们只需将电机反转并继续移动。"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:206
#: da9fc3dabfee494aa632bf5f0e12b0dd
msgid ""
"In order to solve this problem, we implement what we call inversion "
"awareness . If we assume we know the wheel's current azimuth angle, and "
"we've calculated the azimuth we need, we can check if we'd need to “flip” "
"our module or not. If we would, we can just invert the speed output, "
"readjust where our azimuth is headed, and continue on our way. We'll "
"implement this in a bit."
msgstr ""
"为了解决这个问题，我们实现了所谓的“智能反转”。如果我们知道车轮当前的方位角，并且我们已经计算出我们需要的方位角，我们可以检查我们是否需要 "
"\"反转\"我们的模块。如果需要，我们只需反转速度输出，并重新调整方位角的方向，然后继续移动。我们将在稍后实现这一点。"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:212
#: fdd153c9123a4156a7c2d11336e13b93
msgid "Power to the ground (Speed and Azimuth drivers)"
msgstr "落实控制算法（改变轮子的速度并旋转朝向）"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:213
#: f8c2a8461cbc426b81a5560e4cbba4ff
msgid ""
"Finally, we're at the point where we can get things moving. We have the "
"parameters we want, a set of wheel speeds and angles, generated from our "
"desired output, transformed to be oriented relative to the field. Now we "
"want to get our swerve modules to execute those commands. These next bits of"
" code can be considered analogous to drivers in a computer system - layers "
"of code that handle the nitty-gritty low-level communication and control "
"while providing an abstracted interface for control. In our case, we grouped"
" azimuth and wheel speed into one module that we can use to set a wheel's "
"target state."
msgstr ""
"终于，我们可以开始行动了。我们有了我们想要的参数，一组轮子的速度和角度，从我们想要的输出中产生，被变换为相对于机器人的方向。现在我们要让我们的转向模块执行这些指令。接下来的这些代码可以被认为类似于计算机系统中的驱动程序"
"--"
"在提供一个抽象的控制界面的同时，处理琐碎的低级通信和控制的代码层。在我们的案例中，我们将方位角和车轮速度归纳为一个模块，我们可以用它来设置车轮的目标状态。"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:222
#: e20d9773190c48f29e38ef8a8b84e4a4
msgid "Azimuth"
msgstr "改变朝向"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:223
#: 49faebc9d31341d4a26c9a26544e1c75
msgid ""
"Azimuth control is accomplished using a proportional feedback controller "
"sensing the angle of the wheel with an absolute encoder. Depending on the "
"specific encoder used, this may come in the form of a degree value, a "
"voltage, or an integer number of ticks. For our US Digital MA3 encoders, the"
" output is in the form of a 0-5V signal, with the full range representing "
"360° of rotation. In many cases, the encoder housing cannot repeatably and "
"precisely be oriented to the “correct” physical position. This means that "
"the reading of our encoder when our azimuth is straight forward (0°, the "
"wheel is straight) can be any value. As such, we're going to have some "
"offset value on a per-module basis, and we'll factor it into our "
"calculations."
msgstr ""
"朝向控制是通过一个比例反馈控制器来完成的，该控制器通过一个轴编码器感应车轮的角度。根据所使用的编码器的不同，读到的数可能是一个度值、一个电压或整数个刻度的形式。对于我们的US"
" Digital MA3编码器，输出是0-5V信号的形式，代表0-360°。在许多情况下，编码器外壳不能精确地定向到 \"正确 "
"\"的物理位置。这意味着，当我们的目的是是直行时（Wa=0°，轮子是朝前的），我们的编码器的读数可以不为0。因此，我们将在每个模块的基础上有一些偏移值，我们将把它纳入我们的计算。"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:232
#: 4db778f4f23941b6b9b86d4b32be5151
msgid ""
"For our feedback controller, we need to calculate the error between our "
"setpoint and position. Because we're working with angles and have a range of"
" 0-360°, we need to use the remainder function to make sure our error is "
"calculated properly. We'll also use this for incorporating our offset. "
"Assuming we have the angle we want for this wheel (wa), we can calculate our"
" error:"
msgstr ""
"对于我们的控制器，我们需要计算我们的目标点和当前位置之间的偏差，即Error值。因为我们是用角度计算的，而且范围是0-360°，所以我们需要使用取余函数来确保我们的误差得到正确计算。我们也会用它来计算我们的偏移量。假设我们有这个轮子想要的角度（wa），我们可以据此计算出我们的偏差值。"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:244
#: 9207dbc347694f0190f9e857f2e7f641
msgid "Inversion Awareness"
msgstr "智能反转"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:245
#: ff420b09384344baa18bd21ef9e7fd87
msgid ""
"Using the Talon FX's SetInverted method makes implementing inversion control"
" very straightforward. We simply “flip” our azimuth error to the other side."
msgstr "使用Talon FX的SetInverted函数可以非常直接地实现反转控制。而我们只需方位角偏差 \"翻转 \"到另一边。"
