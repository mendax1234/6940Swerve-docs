# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2022, Daniel Webber (mendax1234)
# This file is distributed under the same license as the 6940 Swerve package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# zhang jiaming, 2022
# Daniel Webber, 2022
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: 6940 Swerve\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-07-31 04:34+0000\n"
"PO-Revision-Date: 2022-07-04 16:26+0000\n"
"Last-Translator: Daniel Webber, 2022\n"
"Language-Team: Chinese (China) (https://www.transifex.com/frc-team-6940-1/teams/135321/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:2
#: 103addd674964637a2f9442462ce043d
msgid "The Maths"
msgstr "数学部分"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:5
#: 9bb0b3c777c5416bb99f569e886b3752
msgid "Controls and Inputs"
msgstr "控制与输入处理"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:7
#: f5311178b4fb476d9d71f785b5a79cb7
msgid ""
"The driver has some intended output that they'd like the robot to do. In "
"order to communicate this, we define three command inputs - Forward, Strafe,"
" and Rotation, or :math:`FWD`, :math:`STR`, and ROT. Let's define these as "
"variables, each going from -1 to 1, with 0 indicating no control input. "
"There are many ways to map driver inputs to these commands via joysticks, "
"but we chose to use a method where one stick controls translation rate (FWD "
"and :math:`STR`) and the other's left-right axis controls rotation rate "
"(ROT), as shown on the controller. These joysticks are implemented using "
"standard libraries in WPILib, and input is filtered and transformed to "
"provide a better experience to the drivers. In addition to the driver's "
"inputs, we can have inputs incorporated."
msgstr ""
"在操纵时，driver希望机器人可以按照他们的想法行动，而为了将driver的想法与实际程序联系起来，我们定义了三个输入变量，:math:`FWD`, "
":math:`STR`, 与 "
":math:`ROT`，它们的取值范围是-1到1。其中，0代表没有输入数据的情况。有许多方法来将driver的输入映射到该范围中。而在本案例中，我们决定用一个摇杆来控制移动速率（即"
" :math:`FWD`与 "
":math:`STR`），另一个摇杆来控制旋转速率（即ROT）。如图所示。这些摇杆采用WPILib的标准库实现，输入经过筛选和变换以便于driver使用。除了driver的输入变量，我们也可以把别的输入变量纳入考虑。"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:20
#: 19bf43c7ee4f4ddba0acbf762ca9d0e4
msgid "In addition to the driver's inputs, we can have inputs incorporated."
msgstr "除了driver的输入变量，我们也可以把别的输入变量纳入考虑。"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:23
#: 5be53aef112b47beac0161b18640080a
msgid "Field Centric Transformation"
msgstr "以场地为参照系的数据变换"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:25
#: c21a57bb1a524661909290b5e0ba9187
msgid ""
"Once we know the intended movement that the robot should be making, we "
"should apply our field-centric math. This is what's known as a "
"transformation . In simple terms, we take what we know about the robot's "
"orientation relative to the field - in this case, its angle (as measured by "
"a gyroscope) and our known desired forward/back and strafe commands, and "
"adjust them so that the robot moves relative to the field."
msgstr ""
"一旦我们确定了 :math:`FWD`, :math:`STR`, 与 "
":math:`ROT`的值。我们就要对这些数据进行一些数学变换。简单来说，我们要将以场地为参照系的数据，基于机器人与场地的夹角（由陀螺仪测得），变换为以机器人为参照系的数据，进而使机器人以场地为参照系移动。"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:31
#: f2040f3f1e454d669a992479b75fb9e1
msgid ""
"We define :math:`FWD` and :math:`STR` as the desired forward/back and strafe"
" commands from the joystick, relative to the field. These can both range "
"from -1 to 1 from the joystick, assuming things are filtered correctly, and "
"the magnitude of the input vector (:math:`FWD`, :math:`STR`) shouldn't ever "
"be greater than 1. We'll find that this doesn't matter later."
msgstr ""
"我们定义 :math:`FWD` 和 "
":math:`STR为我们所预期的、来自摇杆的平移指令。它们的取值在1到-1之间，我们假设它们都被正确地过滤。同时两者（作为向量）的和向量的模不应大于1，但晚些时候我们会发现这并不重要。"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:36
#: a12f3d334caf4146b5e2af79d418cafc
msgid ""
"We'll call the angle of the chassis relative to the field θ, and assume that"
" it's 0 when the front of the robot is aligned with the field, away from the"
" driver. This angle can be either defined from -180° to 180°, or from 0 to "
"360 degrees - the math in this case works the same. With these in mind, we "
"can transform our :math:`FWD` and :math:`STR` commands as follows:"
msgstr ""
"我们定义机器人与场地的夹角为θ，当机器人的正面与场地的边框相平行，远离驾驶员时，θ的数值为0。该角度的取值范围既可以是0-360°，也可以是-180°到180°——在该案例中进行数学运算时，两者并无实际区别。进一步地，我们可以将"
" :math:`FWD`与 :math:`STR`作如下变换："

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:41
#: e0c00633a28b48c89051e8f85957fadf
msgid ""
"FWDnew = FWD * cosθ + STR * sinθ\n"
"\n"
msgstr ""
"FWDnew = FWD * cosθ + STR * sinθ\n"
"\n"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:42
#: d0213052611b4e21923cc0ed4a8005e7
msgid ""
"STRnew = STR * cosθ − FWD * sinθ\n"
"\n"
msgstr ""
"STRnew = STR * cosθ − FWD * sinθ\n"
"\n"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:44
#: 2ea340ff0fe54622a00618711a33fe86
msgid ""
"First, we calculate our new :math:`FWD`, which can be thought of as simply "
"figuring out how much of each original command (:math:`FWD` and :math:`STR`)"
" are in the actual direction of the robot's “:math:`FWD`”. Likewise, we can "
"do the same for our :math:`STR` command. This effectively transforms our "
"commands, considered relative to the field , into commands that are relative"
" to the robot , using information about the robot's orientation to the field"
" to align everything. If you know a bit of linear algebra, you might "
"recognize this as the result of a `rotation matrix "
"<https://en.wikipedia.org/wiki/Rotation_matrix>`_ , applied to the vector "
"(:math:`FWD`, :math:`STR`)."
msgstr ""
"首先，我们将我们的:math:`FWD`new计算出来。其可以被认我们原先的指令（ :math:`FWD`与 "
":math:`STR`）在机器人的方向上的分向量之和。类似地，我们将 :math:`STR` "
"也算出来。这一举措将我们的以场地为参照系的平移指令转变为以机器人为参照系的平移指令。如果你学过线性代数，你可能会意识到这实际上是对向量( "
":math:`FWD`, :math:`STR`)进行 `坐标系旋转 "
"<https://en.wikipedia.org/wiki/Rotation_matrix>`_。"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:51
#: 16f0eb1b7e2e44598a743453b83f5ced
msgid ""
"To explain this further, let's look at the results of the the following "
"three situations:"
msgstr "为了进一步深化对这两个式子的理解，让我们来看看下面的几个例子。"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:53
#: cb97391ab403492996bfbcb4c1cab794
msgid "**Example 1: Robot is aligned with field**"
msgstr "**例子1：机器人与场地对齐**"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:55
#: 9ae73e2e9c90411d925c9a6e513e864b
msgid ""
"The key here is to think about what the value of θ is, and how the value of "
"our sines and cosines changes as a result. Here, since we're aligned with "
"the field, :math:`θ=0°`. Let's check our sine and cosine plots to see where "
"that puts us at, in terms of values:"
msgstr ""
"这里的关键是思考θ的值是多少，以及我们的正弦和余弦的值如何随之而变化。在这里，由于我们是与场地对齐的，:math:`θ=0°`。让我们来看看我们的正弦和余函数图像。"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:63
#: c010ebb1ec4e4c01afc6ac32196cfb4d
msgid ""
":math:`cos0°` is 1, and :math:`sin0°` is 0. If we think about a right "
"triangle, with one of its angles being 0° and a hypotenuse of 1, the "
"opposing side of that triangle would have no height - and the adjacent side "
"would have the length of the hypotenuse, or 1. Let's see what our math does "
"with this."
msgstr ""
"如果我们想象一个直角三角形，其中一个角是0°，斜边是1，那么这个三角形的对边就没有高度也就是0--"
"同时邻边就有斜边的长度，也就是1。让我们看看我们的式子的处理结果。"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:67
#: 50cf36b2f3354b7a91c0232f21d96972
msgid ""
"FWD_{new} = FWD * cos(0°) + STR * sin(0°) = FWD * 1 + STR * 0 = FWD\n"
"\n"
msgstr ""
"FWD_{new} = FWD * cos(0°) + STR * sin(0°) = FWD * 1 + STR * 0 = FWD\n"
"\n"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:68
#: 45aa5c8448c04405a92e5146a3f7e5d2
msgid ""
"STR_{new} = STR * cos(0°) − FWD * sin(0°) = STR * 1 − FWD * 0 = STR\n"
"\n"
msgstr ""
"STR_{new} = STR * cos(0°) − FWD * sin(0°) = STR * 1 − FWD * 0 = STR\n"
"\n"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:70
#: 4745e0285b534f13bd3cb5c28fdedf7e
msgid ""
"Our math tells us that we haven't changed anything by doing this! "
"Physically, this makes sense; if the robot is aligned with the field, what "
"it considers to be forward is the same as the field's forward; we don't need"
" to modify our commands at all."
msgstr ""
"我们的式子告诉我们，我们并不需要改变任何东西! 事实上，这是有道理的；如果机器人与场地对齐，它的前方与场地的前方是一样的；我们根本不需要修改我们的指令。"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:74
#: 7359f823d9e34cbf80351abf3a39dc71
msgid "**Example 2: Robot is at 90 degrees to field**"
msgstr "**例子2：机器人与场地呈90度**"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:76
#: f2283a2bf525436daed97bdf1ea1b635
msgid ""
"Let's say that we're now at a right angle to the field; our robot is "
"sideways, so our angle :math:`θ=90°`. Again, let's check our trigonometry. "
":math:`cos90°` = 0, and :math:`sin90°` = 1. What does our math do with "
"these?"
msgstr ""
"假设我们的机器人与场地成直角，即机器人是侧向的，所以我们的角度 :math:`θ=90°`。让我们再看看三角函数的结果。 :math:`cos90°` "
"= 0, :math:`sin90°` = 1. 再让我们看看式子的处理结果。"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:80
#: 86408772caf145dd88e76607879c81b9
msgid ""
"FWD_{new} = FWD * cos(90°) + STR * sin(90°) = FWD * 0 + STR * 1 = STR\n"
"\n"
msgstr ""
"FWD_{new} = FWD * cos(90°) + STR * sin(90°) = FWD * 0 + STR * 1 = STR\n"
"\n"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:81
#: a45a0a557854498083b7e38e3a19d767
msgid ""
"STR_{new} = STR * cos(90°) − FWD * sin(90°) = STR * 0 − FWD * 1 = −FWD\n"
"\n"
msgstr ""
"STR_{new} = STR * cos(90°) − FWD * sin(90°) = STR * 0 − FWD * 1 = −FWD\n"
"\n"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:83
#: 4002bc59e3344bf095f7aee6476bf227
msgid ""
"Our commands have switched (with a small change of sign)! Again, physically,"
" this makes some sense. The robot is sideways; in order to go forward, it "
"has to do what it considers a strafe, and in order to strafe, it has to go "
"what it considers forward."
msgstr ""
"我们的指令被变换了（并且符号有一个小的变化）！事实上，这也是有道理的。机器人是侧向的；为了向前走，它必须做它认为的横向移动，而为了横向移动，它必须走它认为的前进。"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:87
#: 8d4a92a658654e7caea0e10c7b73028b
msgid "**Example 3: Robot is at 30 degrees to field**"
msgstr "**例子3：机器人与场地呈30度**"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:89
#: c929f656e0cf4161b5d51a0b4bec03e7
msgid ""
"We're now at some angle that doesn't produce as nice a result. The robot is "
"aligned differently from the field, so to go straight forward or straight "
"sideways, the robot is going to need to do some combination of what it "
"considers going forward and going sideways. With our angle θ=30°, "
":math:`cos30°` = 0.866, and :math:`sin30°` = 0.5. Following through the "
"equations, then,"
msgstr ""
"我们现在的这个角度并不是很易于想象。机器人的排列方式与场地不同，所以要想直接向前或直接向侧边走。我们需要进行一些比较复杂的数学变换。我们的角度θ=30°，"
" :math:`cos30°` = 0.866, :math:`sin30°` = 0.5. 顺着式子走，那么："

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:93
#: 255ca49f7ae54c019aa416221d8830a5
msgid ""
"FWD_{new} = FWD * cos(30°) + STR * sin(30°) = FWD * 0.866 + STR * 0.5\n"
"\n"
msgstr ""
"FWD_{new} = FWD * cos(30°) + STR * sin(30°) = FWD * 0.866 + STR * 0.5\n"
"\n"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:94
#: 648073275121438586a996e4d6e9106f
msgid ""
"STR_{new} = STR * cos(30°) − FWD * sin(30°) = STR * 0.866 − FWD * 0.5\n"
"\n"
msgstr ""
"STR_{new} = STR * cos(30°) − FWD * sin(30°) = STR * 0.866 − FWD * 0.5\n"
"\n"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:96
#: 04c35fa6ec3b40ce89c02bf695637383
msgid ""
"Both :math:`FWD` and :math:`STR` contribute to each of the transformed "
"values. This pattern will carry through for any non-right angle, and as long"
" as we consider our angle properly (with clockwise as positive) we're good "
"to go!"
msgstr ""
":math:`FWD`和 "
":math:`STR`都对每个转换值有贡献。这种计算方式，将贯穿于任何非直角的运算，而只要我们正确地计算我们的角度（顺时针为正），就可以得到正确的运算结果了！"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:101
#: 7c7848a7a4b54f8486b25d6864f5b557
msgid "Inverse Kinematics (Wheel Speeds and Azimuths)"
msgstr "逆向运动学（计算轮子转速与朝向）"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:103
#: 7379ce9ab06a497d89ae4fa5613a2f3c
msgid ""
"Now that we have our :math:`FWD` and :math:`STR` commands transformed, we "
"need to figure out what each wheel should be doing to execute them. What "
"we're doing here is commonly referred to as `inverse kinematics "
"<https://en.wikipedia.org/wiki/Inverse_kinematics>`_ , or IK. We have some "
"goal output we want to get to, and we have some actuator parameters (or "
"joints) we can adjust, those being our wheel speeds and azimuth angles. "
"Inverse kinematics is the calculation of a unique set of output settings "
"that will give us our overall output. Forward kinematics (which we'll cover "
"elsewhere) is the opposite - determining the state (or pose) we're in based "
"on what our actuators have been doing."
msgstr ""
"现在我们的 :math:`FWD`与 :math:`STR` 都已经被正确转换了。我们接着需要算出每一个轮子的运动参数。这一段的内容通常被称为 "
"`inverse kinematics "
"<https://en.wikipedia.org/wiki/Inverse_kinematics>`_，简称IK。我们有我们想要达到的目标输出，以及可以调整的执行器参数（也称作关节），即我们的车轮速度和朝向。逆向运动学的本质计算一组独特的输出数据，从而得到我们的整体目标输出。正向运动学（我们将在其他地方介绍）与此相反"
"--根据我们的执行器在做的事情来确定我们所处的状态（即姿态）。"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:111
#: bb47821a281e4625872751a7cf6cb872
msgid ""
"First, we should account for the wheel layout. We're going to assume our "
"wheel pods are on the vertices of a rectangle. To put it another way, all "
"four wheel axles are able to lie on some circle. This represents the "
"majority of swerve drive setups (ours was square). If the swerve modules are"
" not on a square (e.g. if the robot is not square), we'll account for that "
"as we make our calculations."
msgstr ""
"首先，我们应该考虑到车轮的布局。我们将假设我们的车轮位于一个矩形的顶点上。换句话说，所有四个轮轴都能处在某个圆上。这代表了大多数swerve驱动的底盘的样子（我们的就是方形）。如果swerve模块不在一个矩形上（例如，如果机器人不是矩形），我们将在计算时考虑到这一点。"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:116
#: dfa35a0190de4cfaba5d0675958801cc
msgid ""
"First, let's define the length and width of our wheelbase as L and W, and "
"let's define an additional value :math:`R`, as :math:`R = \\sqrt{L^2 + W^2}`"
" , or the diameter of the circle that contacts all four wheel axles. The "
"units of these values don't matter, as we're only going to be taking their "
"ratios in our wheel calculations."
msgstr ""
"接着，让我们把轴距的长度和宽度定义为L和W，同时，我们定义一个额外的值 :math:`R`, 其值为 :math:`R = sqrt{L^2 + "
"W^2}`, 代表接触所有四个轮轴的圆的直径。这些值的单位并不重要，因为我们在计算车轮的时候只需要它们的比值。"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:127
#: a740c98f8c144b20853adfe4f13e8480
msgid "Intuition"
msgstr "理想模型"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:128
#: ef7c35adcbcf4634aac6c647dc5190b8
msgid ""
"To understand how we can turn our overall commands (what we want the robot "
"as a whole to do) into what each wheel needs to do, we should build some "
"intuition. It's perfectly possible to borrow the math and program it into "
"place without this, but it really helps to understand how things work under "
"the hood."
msgstr ""
"为了知道如何将我们的对于机器人整体的指令（我们希望机器人作为一个整体做什么）转化为每个轮子的指令，我们应该建立一些理想模型。即使我们不这样做，我们也完全可以借用数学知识并将其编程到位，但这确实有助于了解代码的工作原理。"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:133
#: 1c4f4d5ec6484e24a43088c6b17cb2ab
msgid ""
"As we derive our inverse kinematics, we make some underlying assumptions, "
"including that the robot's chassis acts as a rigid body - within its own "
"reference frame, one point cannot move closer or further away to another "
"point. Imagine a metal cube on a desk. You can move it forward, back, and "
"spin it, but it's solid and unchanging relative to itself. From a kinematics"
" standpoint, there's an important fact we can draw from this. If we look at "
"one side of the robot, all points along it have to have the same velocity "
"forward or backward. If they had different speeds, the side would be "
"changing in length. Hopefully that's not actually happening, and if our "
"robot is built sufficiently rigidly, it shouldn't be."
msgstr ""
"当我们推导反运动学时，我们建立了一个理想模型，我们将机器人的底盘视作一个刚体——在其自身的参照系内，一个点不能靠近或远离另一个点。想象一下，桌子上有一个金属立方体。你可以向前、向后移动它，也可以旋转它，但它是刚体，它的形状是不变的。从物理学的角度来看，我们可以推导出一个重要的结论。对于机器人的每一条边，它上面的所有点都必须具有相同的向前或向后的速度。如果它们有不同的速度，那么这个侧面的长度就会发生变化。真希望这种情况不会发生在赛场上，如果我们的代码写得足够好，就不应该发生这种情况。"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:146
#: a754460dbf2948129e2c3d4e084d09c8
msgid ""
"We can back this assumption out by doing some vector math . ChiefDelphi user"
" Ether's `Derivation of Inverse Kinematics for Swerve "
"<https://www.chiefdelphi.com/t/paper-4-wheel-independent-drive-independent-"
"steering-swerve/107383>`_ document explains this in detail. To do this, we "
"can combine our desired strafe and speed commands into a translation vector "
", and our rotation command can be combined with our robot geometry to form a"
" rotational component. By adding these vectors, we get our required wheel "
"movement vector, in the form of a direction and a magnitude."
msgstr ""
"我们可以通过做一些向量运算来满足这一点。ChiefDelphi用户Ether的 `Derivation of Inverse Kinematics "
"for Swerve <https://www.chiefdelphi.com/t/paper-4-wheel-independent-drive-"
"independent-steering-"
"swerve/107383>`_文件详细解释了这一点。要做到这一点，我们可以将我们所需的横向运动和前后运动指令合并为一个平移矢量，而我们的旋转指令可以与我们的机器人几何形状相结合，形成一个旋转分量。通过添加这些矢量，我们可以得到我们所需的车轮运动矢量，其形式为朝向和转速。"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:153
#: 92fdc90f45974bb494b23dca938d7bfe
msgid ""
"From here, we'll define some variables to save us some work. Standard "
"convention has them as A, B, C, and D."
msgstr "在此，我们定义一些变量来节省我们的工作量。一般我们把它们定义作A、B、C与D。具体定义式如下："

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:156
#: 9e80be9809fb4f2c99336f7450474259
msgid ""
"A = STR - ROT * L/R\n"
"\n"
msgstr ""
"A = STR - ROT * L/R\n"
"\n"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:157
#: 8cfcf1f4ef1d47ed961ca477c15aa8e1
msgid ""
"B = STR + ROT * L/R\n"
"\n"
msgstr ""
"B = STR + ROT * L/R\n"
"\n"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:158
#: ca74631b6f8540318e6e39cd6ed9603e
msgid ""
"C = FWD - ROT * W/R\n"
"\n"
msgstr ""
"C = FWD - ROT * W/R\n"
"\n"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:159
#: a11f653047c24366aff88bc1c6a8c886
msgid ""
"D = FWD - ROT * W/R\n"
"\n"
msgstr ""
"D = FWD - ROT * W/R\n"
"\n"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:161
#: 0efbd164b61d449faf895a1e2a2813fd
msgid ""
"We'll use these to calculate our resultant wheel speeds and wheel angles (or"
" azimuth angles), or ws and wa respectively."
msgstr "我们运用这些数值来计算我们各个轮子的转速与朝向（即wheel speed 与wheel angles，下式中简写为Ws与Wa）"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:164
#: 9c64401088fc48b8884f91ce3c0ddf30
msgid ""
"ws_{FR} = \\sqrt{B^2 + C^2}\n"
"\n"
msgstr ""
"ws_{FR} = \\sqrt{B^2 + C^2}\n"
"\n"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:165
#: 326c258254f44e7ead6c7216f4ce652f
msgid ""
"wa_{FR} = atan2(B,C)\n"
"\n"
msgstr ""
"wa_{FR} = atan2(B,C)\n"
"\n"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:166
#: ca42078d734d45feabb15fd7a7868979
msgid ""
"ws_{FL} = \\sqrt{B^2 + D^2}\n"
"\n"
msgstr ""
"ws_{FL} = \\sqrt{B^2 + D^2}\n"
"\n"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:167
#: 495b71b2f42c41879646fc7283b80214
msgid ""
"wa_{FL} = atan2(B,D)\n"
"\n"
msgstr ""
"wa_{FL} = atan2(B,D)\n"
"\n"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:168
#: a9f1b25599f54b808b324148d43247d3
msgid ""
"ws_{RR} = \\sqrt{A^2 + C^2}\n"
"\n"
msgstr ""
"ws_{RR} = \\sqrt{A^2 + C^2}\n"
"\n"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:169
#: 6d5c97369fb64782b3a82163eda03648
msgid ""
"wa_{RR} = atan2(A,C)\n"
"\n"
msgstr ""
"wa_{RR} = atan2(A,C)\n"
"\n"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:170
#: 46557e75f0a8411b8e0f0e7b38c54e26
msgid ""
"ws_{RL} = \\sqrt{A^2 + D^2}\n"
"\n"
msgstr ""
"ws_{RL} = \\sqrt{A^2 + D^2}\n"
"\n"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:171
#: 568f2595040047e8961369ebae9942b4
msgid ""
"wa_{RL} = atan2(A,D)\n"
"\n"
msgstr ""
"wa_{RL} = atan2(A,D)\n"
"\n"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:173
#: 525a77e4e9714d53b09e4de0df4c1280
msgid ""
"The atan2 function is defined in many programming languages, and provides "
"quadrant-aware calculations for the arctangent function, meaning the angle "
"output will range from -π to π, instead of 0 to π/2."
msgstr ""
"此处，atan2函数是一个在许多语言中都被定义的函数，它的返回值是括号内两数之比的arctan值。值得一提的是，它的返回值是 -π 到 π 而不是0 到"
" π/2。"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:175
#: 7db00e2af8644d27809644f886fbcf99
msgid ""
"What we see here is that we have common factors between our wheels. For both"
" front wheels, we have a common horizontal factor B, and for both rear "
"wheels, a different common factor A. For both right wheels, and left, we see"
" the same thing, with common forward/backward components C and D. This is "
"the mathematical realization of the fact that our robot's chassis can't "
"change in size or shape. Bonus: if you know a bit of vector math, you'll "
"notice that we're doing a transformation from cartesian to polar "
"coordinates."
msgstr ""
"在此，我们可以看到，不同的车轮之间有共同的因子。对于两个前轮，我们有一个共同的水平因子B，对于两个后轮，有一个共同因子A。对于两个右轮和左轮，同样地，有共同的前后移动分量C和D。如果你知道一点向量知识，你会意识到我们实际上做了一个从平面直角坐标到极坐标的转换。"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:182
#: dd9ead06acc2492eaf5871d86874e6dd
msgid ""
"Where FR, FL, RR, and RL refer to front right, front left, rear right, and "
"rear left wheels. Our azimuth angles should range from -π to π, with "
"positive as clockwise and zero being straight π π ahead. These can be "
"converted to degrees as necessary - just multiply by 180/π . Our wheel "
"speeds should range from 0 to 1, absolute, but we'll need to check if they "
"need to be normalized. To do this, we just check if the maximum of our ws "
"values is greater than 1, and if it is, scale the values such that it's 1."
msgstr ""
"其中FR、FL、RR和RL指的是右前、左前、右后和左后轮。我们的算得的朝向的数值是从-"
"π到π，正数为顺时针方向，零为直行。这些可以根据需要转换为度数——只要乘以180/π。我们的轮速的绝对值应该在0到1之间。为此，我们只需检查我们的ws值的最大值是否大于1，如果是，就将这些值按比例放缩，使ws的最大值为1。"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:197
#: 3f4b8524bd2f44f2b99b7c683bb0569d
msgid ""
"Now we have all ws values ranging from 0 to 1. The wheel speed assumed to be"
" in the direction the wheel is facing ( wa ), and thus does not go negative,"
" as that would imply the wheel has turned 180°."
msgstr "现在，我们算出了所有的ws值，范围从0到1。ws的值不应为负数，因为这意味着轮子的朝向（即wa）值应当再转180°"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:200
#: dfa7672943f74e82afd3865f72d8e28c
msgid ""
"Our algorithm to this point brings up a problem. If our control input "
"quickly changes from, for example, moving entirely forward to moving "
"backward, our wheel pods need to turn all the way around in order to execute"
" the new command. Given that we're working with motors that can go full "
"power forward or backward, that's an inefficient thing to do. Ideally, we'd "
"just flip the motor into reverse and move on."
msgstr ""
"但现在，我们的算法带来了一个问题。 如果我们的控制输入快速从全速向前变为全速向后移动，我们的轮舱需要旋转180°才能执行新命令。 "
"鉴于我们正在使用可以全功率前进或后退的电机，这是一件低效的事情。 理想情况下，我们只需将电机反转并继续移动。"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:206
#: b8ec02690e124c63ba06c5cca9e914cb
msgid ""
"In order to solve this problem, we implement what we call inversion "
"awareness . If we assume we know the wheel's current azimuth angle, and "
"we've calculated the azimuth we need, we can check if we'd need to “flip” "
"our module or not. If we would, we can just invert the speed output, "
"readjust where our azimuth is headed, and continue on our way. We'll "
"implement this in a bit."
msgstr ""
"为了解决这个问题，我们实现了所谓的“智能反转”。如果我们知道车轮当前的方位角，并且我们已经计算出我们需要的方位角，我们可以检查我们是否需要 "
"\"反转\"我们的模块。如果需要，我们只需反转速度输出，并重新调整方位角的方向，然后继续移动。我们将在稍后实现这一点。"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:212
#: b3d5d67841f448c0992a5b4c657cdb46
msgid "Power to the ground (Speed and Azimuth drivers)"
msgstr "落实控制算法（改变轮子的速度并旋转朝向）"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:213
#: 206bd7d01a6f46309c57a74140a840c8
msgid ""
"Finally, we're at the point where we can get things moving. We have the "
"parameters we want, a set of wheel speeds and angles, generated from our "
"desired output, transformed to be oriented relative to the field. Now we "
"want to get our swerve modules to execute those commands. These next bits of"
" code can be considered analogous to drivers in a computer system - layers "
"of code that handle the nitty-gritty low-level communication and control "
"while providing an abstracted interface for control. In our case, we grouped"
" azimuth and wheel speed into one module that we can use to set a wheel's "
"target state."
msgstr ""
"终于，我们可以开始行动了。我们有了我们想要的参数，一组轮子的速度和角度，从我们想要的输出中产生，被变换为相对于机器人的方向。现在我们要让我们的转向模块执行这些指令。接下来的这些代码可以被认为类似于计算机系统中的驱动程序"
"--"
"在提供一个抽象的控制界面的同时，处理琐碎的低级通信和控制的代码层。在我们的案例中，我们将方位角和车轮速度归纳为一个模块，我们可以用它来设置车轮的目标状态。"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:222
#: cf922b2c8ebf4ad1864075b810089539
msgid "Azimuth"
msgstr "改变朝向"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:223
#: 86877cf5c756455cbe831500694942ad
msgid ""
"Azimuth control is accomplished using a proportional feedback controller "
"sensing the angle of the wheel with an absolute encoder. Depending on the "
"specific encoder used, this may come in the form of a degree value, a "
"voltage, or an integer number of ticks. For our US Digital MA3 encoders, the"
" output is in the form of a 0-5V signal, with the full range representing "
"360° of rotation. In many cases, the encoder housing cannot repeatably and "
"precisely be oriented to the “correct” physical position. This means that "
"the reading of our encoder when our azimuth is straight forward (0°, the "
"wheel is straight) can be any value. As such, we're going to have some "
"offset value on a per-module basis, and we'll factor it into our "
"calculations."
msgstr ""
"朝向控制是通过一个比例反馈控制器来完成的，该控制器通过一个轴编码器感应车轮的角度。根据所使用的编码器的不同，读到的数可能是一个度值、一个电压或整数个刻度的形式。对于我们的US"
" Digital MA3编码器，输出是0-5V信号的形式，代表0-360°。在许多情况下，编码器外壳不能精确地定向到 \"正确 "
"\"的物理位置。这意味着，当我们的目的是是直行时（Wa=0°，轮子是朝前的），我们的编码器的读数可以不为0。因此，我们将在每个模块的基础上有一些偏移值，我们将把它纳入我们的计算。"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:232
#: 3ad4f5b191184f758581ad3020c33036
msgid ""
"For our feedback controller, we need to calculate the error between our "
"setpoint and position. Because we're working with angles and have a range of"
" 0-360°, we need to use the remainder function to make sure our error is "
"calculated properly. We'll also use this for incorporating our offset. "
"Assuming we have the angle we want for this wheel (wa), we can calculate our"
" error:"
msgstr ""
"对于我们的控制器，我们需要计算我们的目标点和当前位置之间的偏差，即Error值。因为我们是用角度计算的，而且范围是0-360°，所以我们需要使用取余函数来确保我们的误差得到正确计算。我们也会用它来计算我们的偏移量。假设我们有这个轮子想要的角度（wa），我们可以据此计算出我们的偏差值。"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:244
#: 6b7c64257fa94b06b1ed4e27480c899e
msgid "Inversion Awareness"
msgstr "智能反转"

#: ../source/docs/software-info-team1684/swerve-in-teleop/the-math.rst:245
#: 7f1a8516210a4c12b569a2071b98cbce
msgid ""
"Using the Talon FX's SetInverted method makes implementing inversion control"
" very straightforward. We simply “flip” our azimuth error to the other side."
msgstr "使用Talon FX的SetInverted函数可以非常直接地实现反转控制。而我们只需方位角偏差 \"翻转 \"到另一边。"
