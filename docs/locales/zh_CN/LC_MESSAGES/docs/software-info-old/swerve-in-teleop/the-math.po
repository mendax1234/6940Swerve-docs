# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2022, Wenbo Zhu (mendax1234)
# This file is distributed under the same license as the 6940 Swerve Documentation package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: 6940 Swerve Documentation 0.1.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-05-02 16:26+0800\n"
"PO-Revision-Date: 2022-05-02 09:30+0000\n"
"Language-Team: Chinese (China) (https://www.transifex.com/frc-team-6940-1/teams/135321/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../source/docs/software-info-old/swerve-in-teleop/the-math.rst:2
#: e5b1bdbd0a6a47efa06a813857a33d68
msgid "The Maths"
msgstr ""

#: ../../source/docs/software-info-old/swerve-in-teleop/the-math.rst:5
#: d5160ef035fd4402afdb93e95fdfe345
msgid "Controls and Inputs"
msgstr ""

#: ../../source/docs/software-info-old/swerve-in-teleop/the-math.rst:7
#: 3dcb6d90b2f0436bb170ac256f6a3303
msgid ""
"The driver has some intended output that they’d like the robot to do. In "
"order to communicate this, we define three command inputs - Forward, Strafe,"
" and Rotation, or :math:`FWD`, :math:`STR`, and ROT. Let’s define these as "
"variables, each going from -1 to 1, with 0 indicating no control input. "
"There are many ways to map driver inputs to these commands via joysticks, "
"but we chose to use a method where one stick controls translation rate (FWD "
"and :math:`STR`) and the other’s left-right axis controls rotation rate "
"(ROT), as shown on the controller. These joysticks are implemented using "
"standard libraries in WPILib, and input is filtered and transformed to "
"provide a better experience to the drivers. In addition to the driver’s "
"inputs, we can have inputs incorporated."
msgstr ""

#: ../../source/docs/software-info-old/swerve-in-teleop/the-math.rst:20
#: f69da494f1ea4997bd85478624302fb8
msgid "In addition to the driver’s inputs, we can have inputs incorporated."
msgstr ""

#: ../../source/docs/software-info-old/swerve-in-teleop/the-math.rst:23
#: 31c820d14e304259a6e61ffbd5246669
msgid "Field Centric Transformation"
msgstr ""

#: ../../source/docs/software-info-old/swerve-in-teleop/the-math.rst:25
#: d5abf86fdaa34db98d37f74d2860bf40
msgid ""
"Once we know the intended movement that the robot should be making, we "
"should apply our field-centric math. This is what’s known as a "
"transformation . In simple terms, we take what we know about the robot’s "
"orientation relative to the field - in this case, its angle (as measured by "
"a gyroscope) and our known desired forward/back and strafe commands, and "
"adjust them so that the robot moves relative to the field."
msgstr ""

#: ../../source/docs/software-info-old/swerve-in-teleop/the-math.rst:31
#: a25147d780f544958736d9eb10c82941
msgid ""
"We define :math:`FWD` and :math:`STR` as the desired forward/back and strafe"
" commands from the joystick, relative to the field. These can both range "
"from -1 to 1 from the joystick, assuming things are filtered correctly, and "
"the magnitude of the input vector (:math:`FWD`, :math:`STR`) shouldn’t ever "
"be greater than 1. We’ll find that this doesn’t matter later."
msgstr ""

#: ../../source/docs/software-info-old/swerve-in-teleop/the-math.rst:36
#: 2628c23e8d5d4118b6af4c91d98f8f4e
msgid ""
"We’ll call the angle of the chassis relative to the field θ, and assume that"
" it’s 0 when the front of the robot is aligned with the field, away from the"
" driver. This angle can be either defined from -180° to 180°, or from 0 to "
"360 degrees - the math in this case works the same. With these in mind, we "
"can transform our :math:`FWD` and :math:`STR` commands as follows:"
msgstr ""

#: ../../source/docs/software-info-old/swerve-in-teleop/the-math.rst:41
#: 76f4de15bf5243cc86c47d0e72a16bb4
msgid ""
"FWDnew = FWD * cosθ + STR * sinθ\n"
"\n"
msgstr ""

#: ../../source/docs/software-info-old/swerve-in-teleop/the-math.rst:42
#: 02b4107ff8a24b7fb882500f49fe2e3f
msgid ""
"STRnew = STR * cosθ − FWD * sinθ\n"
"\n"
msgstr ""

#: ../../source/docs/software-info-old/swerve-in-teleop/the-math.rst:44
#: 81290cb8ac464e8da149b28bada15942
msgid ""
"First, we calculate our new :math:`FWD`, which can be thought of as simply "
"figuring out how much of each original command (:math:`FWD` and :math:`STR`)"
" are in the actual direction of the robot’s “:math:`FWD`”. Likewise, we can "
"do the same for our :math:`STR` command. This effectively transforms our "
"commands, considered relative to the field , into commands that are relative"
" to the robot , using information about the robot’s orientation to the field"
" to align everything. If you know a bit of linear algebra, you might "
"recognize this as the result of a rotation matrix , applied to the vector "
"(:math:`FWD`, STR)."
msgstr ""

#: ../../source/docs/software-info-old/swerve-in-teleop/the-math.rst:51
#: f25f37cfe75e4720be100f62390fd3e7
msgid ""
"Our ROT (rotation) command actually doesn’t come into play at all in this "
"transformation. To understand why this is, consider that"
msgstr ""

#: ../../source/docs/software-info-old/swerve-in-teleop/the-math.rst:54
#: 0eee3be0647c42dc9879b936fcb6d1bc
msgid ""
"To explain this further, let’s look at the results of the the following "
"three situations:"
msgstr ""

#: ../../source/docs/software-info-old/swerve-in-teleop/the-math.rst:56
#: 801642406e0d4c8a95111591b89355b7
msgid "**Example 1: Robot is aligned with field**"
msgstr ""

#: ../../source/docs/software-info-old/swerve-in-teleop/the-math.rst:58
#: 0ea170e8dad34053b9bfef8fd1664920
msgid ""
"The key here is to think about what the value of θ is, and how the value of "
"our sines and cosines changes as a result. Here, since we’re aligned with "
"the field, :math:`θ=0°`. Let’s check our sine and cosine plots to see where "
"that puts us at, in terms of values:"
msgstr ""

#: ../../source/docs/software-info-old/swerve-in-teleop/the-math.rst:66
#: 99cdf21ce7de458eaaaeb02bbed5663a
msgid ""
":math:`cos0°` is 1, and :math:`sin0°` is 0. If we think about a right "
"triangle, with one of its angles being 0° and a hypotenuse of 1, the "
"opposing side of that triangle would have no height - and the adjacent side "
"would have the length of the hypotenuse, or 1. Let’s see what our math does "
"with this."
msgstr ""

#: ../../source/docs/software-info-old/swerve-in-teleop/the-math.rst:70
#: 38e3e05e05d945bcb1382fefa149ca61
msgid ""
"FWD_{new} = FWD * cos(0°) + STR * sin(0°) = FWD * 1 + STR * 0 = FWD\n"
"\n"
msgstr ""

#: ../../source/docs/software-info-old/swerve-in-teleop/the-math.rst:71
#: b92fd711ec854180872f1982f320494f
msgid ""
"STR_{new} = STR * cos(0°) − FWD * sin(0°) = STR * 1 − FWD * 0 = STR\n"
"\n"
msgstr ""

#: ../../source/docs/software-info-old/swerve-in-teleop/the-math.rst:73
#: 553d86613b8e42e49d0af56ba567c0c5
msgid ""
"Our math tells us that we haven’t changed anything by doing this! "
"Physically, this makes sense; if the robot is aligned with the field, what "
"it considers to be forward is the same as the field’s forward; we don’t need"
" to modify our commands at all."
msgstr ""

#: ../../source/docs/software-info-old/swerve-in-teleop/the-math.rst:77
#: 5b74188dc89645de992e93050bd69463
msgid "**Example 2: Robot is at 90 degrees to field**"
msgstr ""

#: ../../source/docs/software-info-old/swerve-in-teleop/the-math.rst:79
#: 9f720094b9354277a520d34003ab27d3
msgid ""
"Let’s say that we’re now at a right angle to the field; our robot is "
"sideways, so our angle :math:`θ=90°`. Again, let’s check our trigonometry. "
":math:`cos90°` = 0, and :math:`sin90°` = 1. What does our math do with "
"these?"
msgstr ""

#: ../../source/docs/software-info-old/swerve-in-teleop/the-math.rst:83
#: 38e3e05e05d945bcb1382fefa149ca61
msgid ""
"FWD_{new} = FWD * cos(90°) + STR * sin(90°) = FWD * 0 + STR * 1 = STR\n"
"\n"
msgstr ""

#: ../../source/docs/software-info-old/swerve-in-teleop/the-math.rst:84
#: b92fd711ec854180872f1982f320494f
msgid ""
"STR_{new} = STR * cos(90°) − FWD * sin(90°) = STR * 0 − FWD * 1 = −FWD\n"
"\n"
msgstr ""

#: ../../source/docs/software-info-old/swerve-in-teleop/the-math.rst:86
#: a28e5e10bc5f44c5a65149c3f261f16c
msgid ""
"Our commands have switched (with a small change of sign)! Again, physically,"
" this makes some sense. The robot is sideways; in order to go forward, it "
"has to do what it considers a strafe, and in order to strafe, it has to go "
"what it considers forward."
msgstr ""

#: ../../source/docs/software-info-old/swerve-in-teleop/the-math.rst:90
#: bfffce344c5041eb8b2daa49de7ab846
msgid "**Example 3: Robot is at 30 degrees to field**"
msgstr ""

#: ../../source/docs/software-info-old/swerve-in-teleop/the-math.rst:92
#: e35236a738e54ef1b057681e79b6b1cc
msgid ""
"We’re now at some angle that doesn’t produce as nice a result. The robot is "
"aligned differently from the field, so to go straight forward or straight "
"sideways, the robot is going to need to do some combination of what it "
"considers going forward and going sideways. With our angle θ=30°, "
":math:`cos30°` = 0.866, and :math:`sin30°` = 0.5. Following through the "
"equations, then,"
msgstr ""

#: ../../source/docs/software-info-old/swerve-in-teleop/the-math.rst:96
#: 80ed21b4bb91418e9f73f3eb9afa6ca9
msgid ""
"FWD_{new} = FWD * cos(30°) + STR * sin(30°) = FWD * 0.866 + STR * 0.5\n"
"\n"
msgstr ""

#: ../../source/docs/software-info-old/swerve-in-teleop/the-math.rst:97
#: a8c95900862242c6962488be1d23f766
msgid ""
"STR_{new} = STR * cos(30°) − FWD * sin(30°) = STR * 0.866 − FWD * 0.5\n"
"\n"
msgstr ""

#: ../../source/docs/software-info-old/swerve-in-teleop/the-math.rst:99
#: f0d5adbe445045578758afe1a708fb2c
msgid ""
"Both :math:`FWD` and :math:`STR` contribute to each of the transformed "
"values. This pattern will carry through for any non-right angle, and as long"
" as we consider our angle properly (with clockwise as positive) we’re good "
"to go!"
msgstr ""

#: ../../source/docs/software-info-old/swerve-in-teleop/the-math.rst:104
#: ee05298cc8cf452795341f9c37dcdc29
msgid "Inverse Kinematics (Wheel Speeds and Azimuths)"
msgstr ""

#: ../../source/docs/software-info-old/swerve-in-teleop/the-math.rst:106
#: fd0b209811be4e47942713c1ebb33d16
msgid ""
"Now that we have our :math:`FWD` and :math:`STR` commands transformed, we "
"need to figure out what each wheel should be doing to execute them. What "
"we’re doing here is commonly referred to as `inverse kinematics "
"<https://en.wikipedia.org/wiki/Inverse_kinematics>`_ , or IK. We have some "
"goal output we want to get to, and we have some actuator parameters (or "
"joints) we can adjust, those being our wheel speeds and azimuth angles. "
"Inverse kinematics is the calculation of a unique set of output settings "
"that will give us our overall output. Forward kinematics (which we’ll cover "
"elsewhere) is the opposite - determining the state (or pose) we’re in based "
"on what our actuators have been doing."
msgstr ""

#: ../../source/docs/software-info-old/swerve-in-teleop/the-math.rst:114
#: e1c79c41685c4d8ca939fce6bc740f53
msgid ""
"First, we should account for the wheel layout. We’re going to assume our "
"wheel pods are on the vertices of a rectangle. To put it another way, all "
"four wheel axles are able to lie on some circle. This represents the "
"majority of swerve drive setups (ours was square). If the swerve modules are"
" not on a square (e.g. if the robot is not square), we’ll account for that "
"as we make our calculations."
msgstr ""

#: ../../source/docs/software-info-old/swerve-in-teleop/the-math.rst:119
#: d6e3575f483e48558e9d2aeeb1ea149a
msgid ""
"First, let’s define the length and width of our wheelbase as L and W, and "
"let’s define an additional value :math:`R`, as :math:`R = \\sqrt{L^2 + W^2}`"
" , or the diameter of the circle that contacts all four wheel axles. The "
"units of these values don’t matter, as we’re only going to be taking their "
"ratios in our wheel calculations."
msgstr ""

#: ../../source/docs/software-info-old/swerve-in-teleop/the-math.rst:130
#: 6eab207c0be643da8fe24e91ba149221
msgid "Intuition"
msgstr ""

#: ../../source/docs/software-info-old/swerve-in-teleop/the-math.rst:131
#: 8b8d7cf019ea4d858a6755018320fef6
msgid ""
"To understand how we can turn our overall commands (what we want the robot "
"as a whole to do) into what each wheel needs to do, we should build some "
"intuition. It’s perfectly possible to borrow the math and program it into "
"place without this, but it really helps to understand how things work under "
"the hood."
msgstr ""

#: ../../source/docs/software-info-old/swerve-in-teleop/the-math.rst:136
#: e610358d66114a0c843da5b927f788ad
msgid ""
"As we derive our inverse kinematics, we make some underlying assumptions, "
"including that the robot’s chassis acts as a rigid body - within its own "
"reference frame, one point cannot move closer or further away to another "
"point. Imagine a metal cube on a desk. You can move it forward, back, and "
"spin it, but it’s solid and unchanging relative to itself. From a kinematics"
" standpoint, there’s an important fact we can draw from this. If we look at "
"one side of the robot, all points along it have to have the same velocity "
"forward or backward. If they had different speeds, the side would be "
"changing in length. Hopefully that’s not actually happening, and if our "
"robot is built sufficiently rigidly, it shouldn’t be."
msgstr ""

#: ../../source/docs/software-info-old/swerve-in-teleop/the-math.rst:149
#: 9a61fda33db942fcb4393f0cc65c9ea4
msgid ""
"We can back this assumption out by doing some vector math . ChiefDelphi user"
" Ether’s `Derivation of Inverse Kinematics for Swerve "
"<https://www.chiefdelphi.com/t/paper-4-wheel-independent-drive-independent-"
"steering-swerve/107383>`_ document explains this in detail. To do this, we "
"can combine our desired strafe and speed commands into a translation vector "
", and our rotation command can be combined with our robot geometry to form a"
" rotational component. By adding these vectors, we get our required wheel "
"movement vector, in the form of a direction and a magnitude."
msgstr ""

#: ../../source/docs/software-info-old/swerve-in-teleop/the-math.rst:156
#: 4542d5af82444a048a97855f1be78a7f
msgid ""
"From here, we’ll define some variables to save us some work. Standard "
"convention has them as A, B, C, and D."
msgstr ""

#: ../../source/docs/software-info-old/swerve-in-teleop/the-math.rst:159
#: f9be0afd219747a9ae8366f27be9ca61
msgid ""
"A = STR - ROT * L/R\n"
"\n"
msgstr ""

#: ../../source/docs/software-info-old/swerve-in-teleop/the-math.rst:160
#: d8788f4be3d441df975513baab84d4c0
msgid ""
"B = STR + ROT * L/R\n"
"\n"
msgstr ""

#: ../../source/docs/software-info-old/swerve-in-teleop/the-math.rst:161
#: 202ababacb4b4da686c2e57356b09bc9
msgid ""
"C = FWD - ROT * W/R\n"
"\n"
msgstr ""

#: ../../source/docs/software-info-old/swerve-in-teleop/the-math.rst:162
#: a0afd6611cdc497bafdb188dbe12a2b8
msgid ""
"D = FWD - ROT * W/R\n"
"\n"
msgstr ""

#: ../../source/docs/software-info-old/swerve-in-teleop/the-math.rst:164
#: 026aff28452e45a8845fd57f42b86dab
msgid ""
"We’ll use these to calculate our resultant wheel speeds and wheel angles (or"
" azimuth angles), or ws and wa respectively."
msgstr ""

#: ../../source/docs/software-info-old/swerve-in-teleop/the-math.rst:167
#: 0ad0c8157cf04eada93f3f58b9c5b330
msgid ""
"ws_{FR} = \\sqrt{B^2 + C^2}\n"
"\n"
msgstr ""

#: ../../source/docs/software-info-old/swerve-in-teleop/the-math.rst:168
#: bda4bc3fe3f24f4999e5ea137e1b6b66
msgid ""
"wa_{FR} = atan2(B,C)\n"
"\n"
msgstr ""

#: ../../source/docs/software-info-old/swerve-in-teleop/the-math.rst:169
#: 7dc71747a74b44d28ddf4cfd15957aae
msgid ""
"ws_{FL} = \\sqrt{B^2 + D^2}\n"
"\n"
msgstr ""

#: ../../source/docs/software-info-old/swerve-in-teleop/the-math.rst:170
#: 2fd92738543140f3a9facf7dfbf9e8ea
msgid ""
"wa_{FL} = atan2(B,D)\n"
"\n"
msgstr ""

#: ../../source/docs/software-info-old/swerve-in-teleop/the-math.rst:171
#: d08d50ca966145d7afd170bc8e47ee76
msgid ""
"ws_{RR} = \\sqrt{A^2 + C^2}\n"
"\n"
msgstr ""

#: ../../source/docs/software-info-old/swerve-in-teleop/the-math.rst:172
#: 519283e88b05448492a03609df7ad510
msgid ""
"wa_{RR} = atan2(A,C)\n"
"\n"
msgstr ""

#: ../../source/docs/software-info-old/swerve-in-teleop/the-math.rst:173
#: c7a4b21ada5749ca9b42a3b1cbda7333
msgid ""
"ws_{RL} = \\sqrt{A^2 + D^2}\n"
"\n"
msgstr ""

#: ../../source/docs/software-info-old/swerve-in-teleop/the-math.rst:174
#: e884b2efa78f484cac91a79b0084f25e
msgid ""
"wa_{RL} = atan2(A,D)\n"
"\n"
msgstr ""

#: ../../source/docs/software-info-old/swerve-in-teleop/the-math.rst:176
#: 5f75c6d21534456fba108bea356d1cc6
msgid ""
"The atan2 function is defined in many programming languages, and provides "
"quadrant-aware calculations for the arctangent function, meaning the angle "
"output will range from -π to π, instead of 0 to π/2."
msgstr ""

#: ../../source/docs/software-info-old/swerve-in-teleop/the-math.rst:178
#: e849c8ae98aa4584ab88f22e03563f00
msgid ""
"What we see here is that we have common factors between our wheels. For both"
" front wheels, we have a common horizontal factor B, and for both rear "
"wheels, a different common factor A. For both right wheels, and left, we see"
" the same thing, with common forward/backward components C and D. This is "
"the mathematical realization of the fact that our robot’s chassis can’t "
"change in size or shape. Bonus: if you know a bit of vector math, you’ll "
"notice that we’re doing a transformation from cartesian to polar "
"coordinates."
msgstr ""

#: ../../source/docs/software-info-old/swerve-in-teleop/the-math.rst:185
#: cfe29763737f49ddb0ac028f57e8e781
msgid ""
"Where FR, FL, RR, and RL refer to front right, front left, rear right, and "
"rear left wheels. Our azimuth angles should range from -π to π, with "
"positive as clockwise and zero being straight π π ahead. These can be "
"converted to degrees as necessary - just multiply by 180/π . Our wheel "
"speeds should range from 0 to 1, absolute, but we’ll need to check if they "
"need to be normalized. To do this, we just check if the maximum of our ws "
"values is greater than 1, and if it is, scale the values such that it’s 1."
msgstr ""

#: ../../source/docs/software-info-old/swerve-in-teleop/the-math.rst:191
#: b61866c930154278978d7926927bfb9e
msgid ""
"ws_{max} = max(ws_{FR}, ws_{FL}, ws_{RR}, ws_{RL})\n"
"\n"
msgstr ""

#: ../../source/docs/software-info-old/swerve-in-teleop/the-math.rst:192
#: 15de2889887d4f828a58fc6db002903d
msgid ""
"if ws_{max} > 1.0 :\n"
"\n"
msgstr ""

#: ../../source/docs/software-info-old/swerve-in-teleop/the-math.rst:193
#: 50fdb8f2aa344ab594b50421122f62e1
msgid ""
"ws_{FR} = ws_{FR}/ws_{max}\n"
"\n"
msgstr ""

#: ../../source/docs/software-info-old/swerve-in-teleop/the-math.rst:194
#: 6edffbfc62134840a487ac72c3b81062
msgid ""
"ws_{FL} = ws_{FL}/ws_{max}\n"
"\n"
msgstr ""

#: ../../source/docs/software-info-old/swerve-in-teleop/the-math.rst:195
#: aedcee15c26d43d998d47dbfc79ba7d7
msgid ""
"ws_{RR} = ws_{RR}/ws_{max}\n"
"\n"
msgstr ""

#: ../../source/docs/software-info-old/swerve-in-teleop/the-math.rst:196
#: 142091b8894d41cf8a395095c98f52da
msgid ""
"ws_{RL} = ws_{RL}/ws_{max}\n"
"\n"
msgstr ""

#: ../../source/docs/software-info-old/swerve-in-teleop/the-math.rst:198
#: 2c39d76406dc45cb9ad41dad83f99bcb
msgid ""
"Now we have all ws values ranging from 0 to 1. The wheel speed assumed to be"
" in the direction the wheel is facing ( wa ), and thus does not go negative,"
" as that would imply the wheel has turned 180°."
msgstr ""

#: ../../source/docs/software-info-old/swerve-in-teleop/the-math.rst:201
#: dd047a6136df47e780639e986cc89484
msgid ""
"Our algorithm to this point brings up a problem. If our control input "
"quickly changes from, for example, moving entirely forward to moving "
"backward, our wheel pods need to turn all the way around in order to execute"
" the new command. Given that we’re working with motors that can go full "
"power forward or backward, that’s an inefficient thing to do. Ideally, we’d "
"just flip the motor into reverse and move on."
msgstr ""

#: ../../source/docs/software-info-old/swerve-in-teleop/the-math.rst:207
#: 895fde4d70d8418ba039ce245894af62
msgid ""
"In order to solve this problem, we implement what we call inversion "
"awareness . If we assume we know the wheel’s current azimuth angle, and "
"we’ve calculated the azimuth we need, we can check if we’d need to “flip” "
"our module or not. If we would, we can just invert the speed output, "
"readjust where our azimuth is headed, and continue on our way. We’ll "
"implement this in a bit."
msgstr ""

#: ../../source/docs/software-info-old/swerve-in-teleop/the-math.rst:213
#: ee05298cc8cf452795341f9c37dcdc29
msgid "Power to the ground (Speed and Azimuth drivers)"
msgstr ""

#: ../../source/docs/software-info-old/swerve-in-teleop/the-math.rst:214
#: bc0d05f914ee450cbbd078dbe32c5737
msgid ""
"Finally, we’re at the point where we can get things moving. We have the "
"parameters we want, a set of wheel speeds and angles, generated from our "
"desired output, transformed to be oriented relative to the field. Now we "
"want to get our swerve modules to execute those commands. These next bits of"
" code can be considered analogous to drivers in a computer system - layers "
"of code that handle the nitty-gritty low-level communication and control "
"while providing an abstracted interface for control. In our case, we grouped"
" azimuth and wheel speed into one module that we can use to set a wheel’s "
"target state."
msgstr ""

#: ../../source/docs/software-info-old/swerve-in-teleop/the-math.rst:223
#: d9733c1285e2493c8a18f4c524994e6c
msgid "Azimuth"
msgstr ""

#: ../../source/docs/software-info-old/swerve-in-teleop/the-math.rst:224
#: eb9ab6b2ff3f4aab8a627efa7239a260
msgid ""
"Azimuth control is accomplished using a proportional feedback controller "
"sensing the angle of the wheel with an absolute encoder. Depending on the "
"specific encoder used, this may come in the form of a degree value, a "
"voltage, or an integer number of ticks. For our US Digital MA3 encoders, the"
" output is in the form of a 0-5V signal, with the full range representing "
"360° of rotation. In many cases, the encoder housing cannot repeatably and "
"precisely be oriented to the “correct” physical position. This means that "
"the reading of our encoder when our azimuth is straight forward (0°, the "
"wheel is straight) can be any value. As such, we’re going to have some "
"offset value on a per-module basis, and we’ll factor it into our "
"calculations."
msgstr ""

#: ../../source/docs/software-info-old/swerve-in-teleop/the-math.rst:233
#: e796cba929d44c3aa3534e57e6611180
msgid ""
"For our feedback controller, we need to calculate the error between our "
"setpoint and position. Because we’re working with angles and have a range of"
" 0-360°, we need to use the remainder function to make sure our error is "
"calculated properly. We’ll also use this for incorporating our offset. "
"Assuming we have the angle we want for this wheel (wa), we can calculate our"
" error:"
msgstr ""

#: ../../source/docs/software-info-old/swerve-in-teleop/the-math.rst:245
#: eec19feeee214a4ca3dd079b36d435d0
msgid "Inversion Awareness"
msgstr ""

#: ../../source/docs/software-info-old/swerve-in-teleop/the-math.rst:246
#: 315019cc9f9549f990c3888a23da6119
msgid ""
"Using the Talon FX’s SetInverted method makes implementing inversion control"
" very straightforward. We simply “flip” our azimuth error to the other side."
msgstr ""
